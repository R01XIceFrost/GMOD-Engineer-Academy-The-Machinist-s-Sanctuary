@name MPFC v7.2
#Control and setup inputs
@inputs [Pod Cam]:wirelink InstrumentPanelEntity:entity [VarLib ExtraBases]:array Input_PrevWeapon Input_NextWeapon [Rotor1 Rotor2 TailRotor Prop1 Prop2 Prop3 Prop4]:vector [ExternalAutopilotCommand]:string [Joystick]:wirelink
@inputs [Cannon1 Cannon2 Cannon3]:entity [BombardierAimpos]:vector [BombardierDropInput]:number [OptionalFlightStickPosition OptionalCollectivePosition OptionalThrottlePosition]:vector
@outputs [FireCannon1 FireCannon2 FireCannon3 FireMissile1 FireMissile2 DropBombs]:number Reload [Aimpos BallisticSolution]:vector [Gear_Brakes WEP ThrustReverser Gear_Down WS AD LR UD FB Engines_On]:number FCS_SuperElevation:angle Pilot:entity [AuxOut1 AuxOut2 AuxOut3 AuxOut4 StartSequence]:number

#Source: https://youtu.be/8dT43tQBuiA?si=OGSiencTgM8AyPRX

#internal variables
#Controls
@persist PrevWeapon NextWeapon Locked [W A S D R Alt Space Shift Mouse1 Mouse2 MouseUp MouseDown EngagementRange SightLockStatus StickLimits]:number

#Task scheduler & state machine
@persist [Interval150Timer Interval300Timer Interval600Timer Interval1200Timer CoreTimer Tickrate]:number State:string

#Flight computer information
#const
@persist [DEFAULT_HUDINSTRUMENT_COLOR FLIGHT_CPU_INTEGRAL_LOWER_LIMIT FLIGHT_CPU_INTEGRAL_UPPER_LIMIT]:vector [CYCLIC_LIMIT]:number [CYCLIC_LOW_LIMIT CYCLIC_HIGH_LIMIT]:angle [FLIGHT_CPU_INTEGRAL_GAIN FLIGHT_CPU_DERIVATIVE MIN_CONTROL_VALUE Angular_Force Angular_Dampening VECTOR_DAMPING FLAP_EFFECTIVENESS]:number
#settings
@persist Flight_Model:table [Airframe_Bases Airframe_Bases_Inertias Airframe_Bases_Unwelded Airframe_Bases_Airframe_Bases_Unconstrained Airframe_Bases_Masses]:array [CamParent Seat]:entity [Hover_UD_Est Airframe_Bases_Number]:number [COG_Offset COG_Rot_Offset]:vector [TotalMass StartupSpeed]:number
#variables
@persist [ControlRatio PlaneLiftAdjustment LiftRatio CollectiveForce ThrustForce FlapDampening StallDampening]:number [Flypos FlightCPUAirDensityVector]:vector [FlightCPUAngle FlightCPUP FlightCPUI]:angle #internals local only to flight computer
#global, realtime telemetry
@persist [Position BaseVel Velocity Forward LocalVel]:vector [Angle]:angle [BaseVelLen]:number 
#altitude effects
@persist [GroundEffectValue AltitudeEffectValue]:number

#sounds
@persist [Sounds]:array 

#Camera and rotating camera head
@persist Cam_Offset CamThroughGunsight [AimLoc AimForward AimPoint]:vector FLIR ZoomLevel CamDist AimTrace:ranger ThirdPerson [SightHeadPos]:vector SightHeadActive [SightHeadMaster]:entity CamDisabled

#Holo persists
@persist Rotorrate HoloRotorsMode Index [RotorA RotorB]:entity [Propellor_Directions]:array Number_Of_Propellors Scale:vector RotorBlades Tail_Scale:vector TailRotorBlades TailAngleSwap PropellorScale PropellorBlades

#Ballistics data
@persist [BallisticComputerModeChar Missile_Type_1 Missile_Type_2]:string [CannonRangeTable Missile_1_Range_Table Missile_2_Range_Table]:array WeaponSelected CannonSelected:entity Lead:angle [Acf_Drag_Div Is_Armed]:number
@persist [AutomatedBombAimpos BombVel]:vector [BombKg]:number Bomb_Range_Table:table [LockAimpos]:number [LeadEntity]:entity [LeadReferenceAngle]:angle
#radio based ballistics
@persist [RemoteDatalinkWeaponsOverride]:number [RemoteDatalinkRequestPoint]:vector

#Autopilot module
@persist [AP_Waypoints AP_OPCodes]:array AP_CurrentIndex AP_RECORD_KEY:string AP_Record AP_Pushpoint AP_TargetSpeed AP_Flypos:vector AP_AscentRate

#Autolevel module
@persist AutoLevelIntegral AutoLevelProportional LevelZ AutoLevelCollectiveBoost AutoLevelInputSmoothed

#Tercom module
@persist [TERCOM_TIMESTEP TERCOM_FRONT_OFFSET TERCOM_DOWNWARD_RATIO TERCOM_DAMPENING TERCOM_ALTIMETER_EFFECT TERCOM_TARGET_ALTITUDE TERCOM_TRACE_SIZE]:number [TERCOM_TRACE_SIZE_VEC]:vector
@outputs [TerrainFollowingOn]:number 

#Damage module
@persist [DieTimer DamageSystemSpeed DamageBaseCount DamageSystemStart DamageStructural]:number [BurnEffects]:array

#Landing gear
@persist [LandingGear LandingGearWeights]:array [Gear_Model]:string [LandingGearReinflationCycle]:number

#G forces
@persist [GForceAlpha GForceSpeed]:number

#Misc precaches
@persist  UsedSmoother Piloted Base:entity DarkBacking InstrumentPanelScale AvionicsData:array 
#Triggers
@trigger Input_PrevWeapon Input_NextWeapon

#NEW FOR V7
@persist [Cannon1Crates Cannon2Crates Cannon3Crates BombCrates Missile_1_Crates Missile_2_Crates]:array [Cannon_1_Starting_Ammo Cannon_2_Starting_Ammo Cannon_3_Starting_Ammo BOMB_STARTING_AMMO Missile_1_Starting_Ammo Missile_2_Starting_Ammo Missile_1_Guided Missile_2_Guided BombCCRPWindow InstrumentsBacklit FlapVolume BestCCRPDistance]:number
@persist Orientation:quaternion [DiffAng DiffAngI]:angle [NumpadMode SCRLChatted]:number

@persist [EnginePitch DustKickingUp  TaxiMultiplier SelfHealth]:number
@persist [Lase RadarCycle]:number

#polymer turtle
@persist [JoyWS JoyAD JoyLR JoyUD JoyFB]:number
#ifdef effect:setMagnitude(number)
@persist [DustEffect WaterEffect]:effect

#endif
@persist [PilotPing HudReturn GRAVITY_IN_METERS_PER_SECOND CCIPBombDropAltLast]:number [AmmoData]:table [HudEntity]:entity [RotVecI RotVecP]:vector [FLYPOS_AIM_OFFSET_LEN BOMBING_PULLUP_AMOUNT]:number [BombingPullupInput BombDiveDiff]:number
@persist Self:array [Hash WepCool FireWarning]:number

@persist 
@autoupdate on 
#[THIS CODE IS PROVIDED TO YOU COURTESY OF RED AND FRS, WITH HELP FROM FERVIDUSLETUM.  OUR IP IS 70.42.74.154:27015.

CHANGELOG:
added dive bombing sight
    in CCRP mode & flying by mouse, holding fire will make the plane bomb the target (auto-pullup)
added ballistic tables for glide bombs
tree search added for people who don't parent w/ a nocollide because directions are hard.
added tick 50 bomb drop tables (crude but good enough)
updated 50kg bomb drop tables for more precision (old readings were somehow erroneous)
updated ballistics for air to air to fix a small error which led to erroneously close readings
timer on WEP
added ready/notready notif on gun switch

SETUP:
Place upright, facing forward, and weld to your base.  Then, parent it, making sure it retains the weld.
Cam controller and pod, are to be wired to linked controllers for the pilot, parented with nocollides, and close to the e2.
If applicable, use GPSes to mark the location for holo propellors, rotors, etc, and parent them to your base, then wire them.
Input_Next/PrevWeapon should autowire if you reset the e2; if this fails, you can do it manually.
Adjust variables in a separate e2--varlib, enclosed below--and wire it.  This e2 will read the settings in that, and use them.
Because it's in a separate e2, you can use @autoupdate, to smoothly integrate newer versions without having to update your wire--wire does it automatically.
Note you can also get a holo "sight" cam by having parented wth a nocollide on your vehicle a prop with the model "models/xqm/button2.mdl"

CAM SETTINGS
Local to Parent: YES
Clientside move: YES
Localized move:  NO
Clientside zoom: NO
All others: your choice.

CONTROLS

COMMON:
R+Enter         ->      Ignition
LControl        ->      Switches control from keyboard to mouse
Mouse1          ->      Fires weapons
Mouse2          ->      Cycles weapons of type (ex: gun1 -> gun2, missile1 -> missile2)
R+Mouse2        ->      Reload weapons
I               ->      Lase for range
Light           ->      Infrared FLIR
V               ->      Changes [V]iew between 1st & 3rd person
R+V             ->      Changes [V]iew to gunsight cam--if you have the holo sight off the button model, cam goes from there, else it goes from below and forward on airframe
B               ->      Selects [B]ombs
G or C          ->      Selects [G]uns & [C]annons
M               ->      Selects [M]issiles
Alt             ->      Hold/Release Aimpos (for fire & forget or cancelling lead on strafing ground targets), allows free aim in situations where default is not
L               ->      Raise/lower [L]anding gear
[               ->      Aux output 1
]               ->      Aux output 2
R+LControl      ->      Toggle TERCOM on/off
RControl        ->      Override aimpos with remotely-uploaded weapons data, via SCRL encrypted transmission or a bombardier (authorizes their override)
.               ->      Cam off toggle

KEYBOARD:
WASD            ->      Up/down/left/right
Space/Shift     ->      Up-down Collective/Adjust flaps
R+A/D           ->      Pylon turn left/right (like AC-130)
R+W/S           ->      Throttle up/down

MOUSE:
Mouse           ->      Flight Direction
Space/Shift     ->      Adjust Collective/Flaps
W/S             ->      Adjust Throttle
A/D             ->      Roll left/right
A+D             ->      Fly level/taxiing

AUTOPILOT COMMANDS:
ap on/off       ->      Autopilot on/off
Numpad 0-9      ->      Add waypoint of index key pressed, at x/y aimpos with current altitude z
ap set [alt][#] ->      Sets a waypoint [alt] units above ground for index [#]
    Ex: ap set 2500 3 makes coordinate 3 in autopilot aimpos + 2500z
ap cur [alt][#] ->      Sets a waypoint [alt] units above or below current altitude, at aimpos, for index [#]
    Ex: ap cur -500 5 makes coordinate 5 in autopilot aimpos but 500 units below current altitude
ap loop [#1][#2]->      Index #2+1 is to loop back to one
    Ex: ap loop 3 5 makes autopilot fly to point 5, then point 3, then 4, then 5, and back to 3, flying a loop
More documentation on autopilot can be found in the actual code

OTHER VARS:
Fire1/Fire2/Fire3/Fire4 can be linked to guns, obviously.
Gear_down/brakes are for if you have your own landing gear with hydraulics and weld latches (or similar system); they are only outputs
AuxOutput1/2 are just for more misc. crap, like hatches, cockpits, winches, etc.
WEP, or Wartime Emegency Power, is for if you want to weld a thruster to your arse (afterburner), or display some effect like smoke.
WS/AD/LR/UD/FB are your controls, for if you want to use non-MPFC addons (so like, WS would be a -1/1 of your stick input vertically to pitch up or down)

#holo index map
0               camera/gunsight master
44              gforce holo
45-50           holo cam sight
50-59           autopilot holo indicators
60-68           airplane propellors
100-149         helicopter rotors
160-181         holo instrument panel
182-190         hud
191-198         flight controls
450             ref ent for rangetable building

#State map
(first)         init of hard values, loading from onboard memory, function declares for: autopilot, holo sight head, HUD
BOOTING-1       self parent tree search
BOOTING-2       pod selfwiring, landing gear finding, base prop finding, camera setup
BOOTING-3       communications equipment
BOOTING-4       external holo accessory functions, utility functions, creation of holo accessories
BOOTING-5       ballistic functions, internal holo accessory functions
BOOTING-6       something?
IDLE            waits for commands, if pod active starts into key
KEY             wasd control
MOUSE           war thunder style mouse control
TERCOM          ground-skimming flight
AUTO            autopilot on, pilot only guns, follows waypoints via autopilot

#Autopilot explanation
Autopilot uses a command queue, which is last in first out.  Waypoints correspond with indexes, and can be added anywhere
However they are generally added at the end.  The autopilot parses through and goes point ot point like the lines of assembly
A JMP command can be used to jump the autopilot index being parsed to another location, like index 5 can be a jump to index 3 to fly from 3-4
]#
interval(Tickrate)
runOnChat(1)
runOnKeys(Pilot,1)
runOnLast(1)

if(dupefinished())
{
    reset()
}
elseif(changed(State))
{
    setName("MPFC v7\n"+State:upper()+" S/N: " + Hash)
    LevelZ = Position[3] + (Velocity[3])
    AutoLevelCollectiveBoost = 0
    #if(State == "SIM") {Cam["Activated",number] = 0} else {Cam["Activated",number] = Pilot:isValid()}
}
#setting initial variables, processing flight template, saving ammo, declaring camera functions, pre-setting variables
if(first() | duped())
{
    #State-setting
    State = "BOOTING-1"   
    Tickrate = 250
    
    #THIS IS THE ONLY THING YOU SHOULD EVER MODIFY ON MPFC DIRECTLY EVER EVER EVER#
    #This is your DEFAULT color setting for hud instruments, assuming you don't use another thingy
    DEFAULT_HUDINSTRUMENT_COLOR = vec(255,64,0)
    
    #ASSEMBLING VARIABLE LIBRARY--takes our external datacore, and saves it to local memory.
    #Performance
    Maneuverability = VarLib[1,number] 	    #modifier for maneuverability
    Thrust = VarLib[2,number] 			           #forward or lateral thrust, it's all meshed the same
    Lift = VarLib[3,number]                 #Lift force ratio, may adjust to work with some autohovering governor
    Cruisespeed = VarLib[4,number]				      #max lift at this, used to create stall ratios
    Typeofvehicle = VarLib[5,number]			     #selects flight model
    #Personal preferences
    Smoothers = VarLib[6,number]            #Smooths inputs of angles
    CollectiveSmoother = VarLib[7,number]   #smoother for collective only, reduced to 50% purely to make varlibs easier to default.
    ThrustSmoother = VarLib[8,number]       #smoother for thrust only
    #Sounds
    CockpitSound = VarLib[11,string]        #Sound that plays in the cockpit
    EngineSound = VarLib[12,string]         #Sound that plays from engine, pitches with load.
    PropSound = VarLib[13,string]           #Sound that plays from rotors or thrusting, static and unchanging.
    #Optional holo
    Scale = VarLib[18,vector]               #Scale of your main rotors
    RotorBlades = VarLib[19,number]         #Blades on main rotors
    Tail_Scale = VarLib[20,vector]           #Scale of your tail rotor
    TailRotorBlades = VarLib[21,number]     #Blades on tail rotor
    TailAngleSwap = VarLib[24,number]       #Swaps the angle of the tail rotor
    PropellorScale = VarLib[22,number]      #Size of your propellors
    PropellorBlades = VarLib[23,number]     #Blades on your propellors
    #Cam
    Cam_Offset = VarLib[25,vector][3]        #change from MPFC6
    #stick limits
    StickLimits = VarLib[26,number]         #determines how snappy the controls are interpreted as
    #bomb caliber system
    BombKg = VarLib[27,number]              #kilograms of your bombs, for ballistic computer
    #holo instruments
    DarkBacking = VarLib[28,number]         #non-zero value means to have a dark backing for instrumen tpanel
    InstrumentPanelScale = VarLib[29,number] #size of holographic instrument panel
    #Missile ballistic data
    Missile_Type_1 = VarLib[30,string]:upper()
    Missile_Type_2 = VarLib[31,string]:upper()
    #landing gear model
    Gear_Model = VarLib[32,string]           #prop model which is used to scan for landing gear
    CustomForceValues = VarLib[33,vector2]  #custom force values
    #forces
    Angular_Force = 10                      #Angular correction force
    Angular_Dampening = 2                   #Angular damping force
    if(CustomForceValues[1] > 0) {Angular_Force = CustomForceValues[1]}
    if(CustomForceValues[2] > 0) {Angular_Dampening = CustomForceValues[2]}
    
    #Constant variables
    VECTOR_DAMPING = 0.044                   #Damping of 3-dimensional movement, simulates inertia/air resistance
    CYCLIC_LIMIT = 30                        #helicopter cyclic
    CYCLIC_LOW_LIMIT = ang(-CYCLIC_LIMIT,0,-CYCLIC_LIMIT)        #limit of cyclic
    CYCLIC_HIGH_LIMIT = ang(CYCLIC_LIMIT,0,CYCLIC_LIMIT)         #limit of cyclic
    FLIGHT_CPU_INTEGRAL_LOWER_LIMIT = vec(-3)
    FLIGHT_CPU_INTEGRAL_UPPER_LIMIT = vec(3)
    FLIGHT_CPU_INTEGRAL_GAIN = 0.12         #integral amount for raw body force PID
    FLIGHT_CPU_DERIVATIVE = 2.0             #derivative for raw body force pid
    TERCOM_TIMESTEP = 5                     #how far ahead terrain following radar looks, in seconds of flight
    TERCOM_FRONT_OFFSET = 0.1               #how far forward the offset is for tercom range hull
    TERCOM_DOWNWARD_RATIO = 0.15            #how much downward relative to forward tercom radar scans
    TERCOM_DAMPENING = 0.02                 #dampening of vertical velocity when in terrain following flight
    TERCOM_ALTIMETER_EFFECT = 2.0           #how much altimeter bias affects tercom
    TERCOM_TARGET_ALTITUDE = 3              #meters above ground it attempts to fly when it has a nice level surface
    TERCOM_TRACE_SIZE = 5                   #size of tercom ground-scan trace, in meters
    MIN_CONTROL_VALUE = 0.2                 #limit of control value; this is a full stall.
    FLAP_EFFECTIVENESS = 0.25               #determines a percentage to lower the effect of stall & an increase in lift at once.
    Is_Armed = Cannon1:isValid() | Missile_Type_1 | BombKg #guns, bombs, missiles
    Acf_Drag_Div = acfDragDiv()
    GRAVITY_IN_METERS_PER_SECOND = gravity() / 39.37
    FLYPOS_AIM_OFFSET_LEN = 65535
    BOMBING_PULLUP_AMOUNT = 0.00005
    
    BallisticComputerModeChar = "N"   #NOT ARMED
    #Hard controls
    AP_RECORD_KEY = "pad_enter"
    Seat = Pod:entity("Entity")
    TERCOM_TRACE_SIZE_VEC = vec(39.37 * TERCOM_TRACE_SIZE)
    
    #also note, this is a default backup for legacy operation; you should now set it in varlib
    
    #Startup error checks
    Typeofvehicle = clamp(Typeofvehicle,0,9) #Eliminates errors possibly accumulated from idiot chip users who go out of bounds.
    
    #FLIGHT MODEL TEMPLATES--this is where we process flight models
    #Flight model templates - You can analyze these and make more, if you're a competent programmer.  Which you're probably not, if you're bothering to look through this boilerlate.
    if(Typeofvehicle ==0)
    {
        ManeuverabilityMultiplier = ang(1,0.5,4)
        VectorFlightMultiplier = vec(0,0,2)
        VectorDampingMultiplier = vec(0.01,5,6)
        Winglift = 1
        ForeThrust = 0
        CyclicEnabled = 0
        CollectiveEnabled = 0
        RollOnYaw = 1
        CollectiveThrottleBlending = 0
        CyclicTailMixing = 0
        StallEnabled = 1
        SelfLeveling = 0
        GroundEffectMultiplier = 0.4
        CruiseSpeedMod = 0.5
        FlightModelName = "glider"
    }
    elseif(Typeofvehicle ==1)
    {
        ManeuverabilityMultiplier = ang(1.6,0.5,7)
        VectorFlightMultiplier = vec(0.5,0,1.8)
        VectorDampingMultiplier = vec(0.4,5,6)
        Winglift = 1
        ForeThrust = 1
        CyclicEnabled = 0
        CollectiveEnabled = 0
        RollOnYaw = 1
        CollectiveThrottleBlending = 0
        CyclicTailMixing = 0
        StallEnabled = 1
        SelfLeveling = 0
        GroundEffectMultiplier = 0.3  #biplanes get a bit less ground effect because they have two wings, one higher
        CruiseSpeedMod = 0.75
        FlightModelName = "biplane"
    }
    elseif(Typeofvehicle ==2)
    {
        ManeuverabilityMultiplier = ang(1.4,0.5,6.5)
        VectorFlightMultiplier = vec(0.55,0,1.5)
        VectorDampingMultiplier = vec(0.36,5,5.75)
        Winglift = 1
        ForeThrust = 1
        CyclicEnabled = 0
        CollectiveEnabled = 0
        RollOnYaw = 1
        CollectiveThrottleBlending = 0
        CyclicTailMixing = 0
        StallEnabled = 1
        SelfLeveling = 0
        GroundEffectMultiplier = 0.4 #highwings have a higher wing, reduces ground effect slightly
        CruiseSpeedMod = 0.875
        FlightModelName = "highwing"
    }
    elseif(Typeofvehicle ==3)
    {
        ManeuverabilityMultiplier = ang(1.3,0.6,6)
        VectorFlightMultiplier = vec(0.6,0,1.2)
        VectorDampingMultiplier = vec(0.33,6,5.5)
        Winglift = 1
        ForeThrust = 1
        CyclicEnabled = 0
        CollectiveEnabled = 0
        RollOnYaw = 1
        CollectiveThrottleBlending = 0
        CyclicTailMixing = 0
        StallEnabled = 1
        SelfLeveling = 0
        GroundEffectMultiplier = 0.5
        CruiseSpeedMod = 1
        FlightModelName = "plane"
    }
    elseif(Typeofvehicle ==4)
    {
        ManeuverabilityMultiplier = ang(1.25,0.6,6)
        VectorFlightMultiplier = vec(0.575,0,1.1)
        VectorDampingMultiplier = vec(0.33,5,3)
        Winglift = 1
        ForeThrust = 1
        CyclicEnabled = 0
        CollectiveEnabled = 1
        RollOnYaw = 1
        CollectiveThrottleBlending = 0.5
        CyclicTailMixing = 0
        StallEnabled = 1
        SelfLeveling = 0
        GroundEffectMultiplier = 0.5
        CruiseSpeedMod = 1.05
        FlightModelName = "jumpjet"
    }
    elseif(Typeofvehicle ==5)
    {
        ManeuverabilityMultiplier = ang(0.25,0.25,0.25)
        VectorFlightMultiplier = vec(0.5,0.5,1)
        VectorDampingMultiplier = vec(2,2,2)
        Winglift = 0
        ForeThrust = 1
        CyclicEnabled = 0
        CollectiveEnabled = 1
        RollOnYaw = 0
        CollectiveThrottleBlending = 0
        CyclicTailMixing = 0
        StallEnabled = 0
        SelfLeveling = 1
        GroundEffectMultiplier = 0.1
        CruiseSpeedMod = 0.01
        FlightModelName = "airship"
    }
    elseif(Typeofvehicle ==6)
    {
        ManeuverabilityMultiplier = ang(1,1,2)
        VectorFlightMultiplier = vec(0.5,0.5,3)    #was 1,0.3,1.5
        VectorDampingMultiplier = vec(0.4,1.2,3.5)  #was 0.7, 0.7, 1
        Winglift = 0
        ForeThrust = 0
        CyclicEnabled = 1
        CollectiveEnabled = 1
        RollOnYaw = 0
        CollectiveThrottleBlending = 0
        CyclicTailMixing = 2
        StallEnabled = 0
        SelfLeveling = 1
        GroundEffectMultiplier = 0.6
        CruiseSpeedMod = 1
        FlightModelName = "helicopter"
    }
    elseif(Typeofvehicle ==7)
    {
        ManeuverabilityMultiplier = ang(0.9,0.9,3)
        VectorFlightMultiplier = vec(0.6,0.4,3)
        VectorDampingMultiplier = vec(0.3,1.5,4)
        Winglift = 0
        ForeThrust = 1
        CyclicEnabled = 1
        CollectiveEnabled = 1
        RollOnYaw = 0
        CollectiveThrottleBlending = 0.25
        CyclicTailMixing = 2
        StallEnabled = 0
        SelfLeveling = 1
        GroundEffectMultiplier = 0.5
        CruiseSpeedMod = 0.75
        FlightModelName = "gyrodyne"
    }
    elseif(Typeofvehicle ==8)
    {
        ManeuverabilityMultiplier = ang(0.9,1.1,1.1)
        VectorFlightMultiplier = vec(0.5,0.5,1.6)
        VectorDampingMultiplier = vec(0.4,1.2,1.8)
        Winglift = 1
        ForeThrust = 1
        CyclicEnabled = 1
        CollectiveEnabled = 0
        RollOnYaw = 1
        CollectiveThrottleBlending = 0
        CyclicTailMixing = 1
        StallEnabled = 1
        SelfLeveling = 1
        GroundEffectMultiplier = 1
        CruiseSpeedMod = 0.5
        FlightModelName = "autogyro"
    }
    elseif(Typeofvehicle ==9)
    {
        ManeuverabilityMultiplier = ang(1,1.5,1)
        VectorFlightMultiplier = vec(0.4,0,0.5)
        VectorDampingMultiplier = vec(0.2,5,3)
        Winglift = 0.1
        ForeThrust = 1
        CyclicEnabled = 0
        CollectiveEnabled = 0
        RollOnYaw = 0
        CollectiveThrottleBlending = 0
        CyclicTailMixing = 0
        StallEnabled = 1
        SelfLeveling = 1
        GroundEffectMultiplier = 10  #this is its primary method of lift
        CruiseSpeedMod = 1
        FlightModelName = "ekranoplan"
    }
    
    #normalization.  Do not break this.  If you do I will fucking cut you.  I'm serious--don't screw with this.
    local Pool = Maneuverability+Thrust+Lift
    local PoolLimit = 3.5
    local PoolRatio = clamp(PoolLimit/Pool,0,1)
    Maneuverability = clamp(Maneuverability * PoolRatio,0.5,1.5)
    Thrust = clamp(Thrust * PoolRatio,0.5,1.5)
    Lift = clamp(Lift * PoolRatio,0.5,1.5)
    Cruisespeed = max(Cruisespeed,Thrust * (1000 * CruiseSpeedMod) * (1/Lift))
    SelfHealth = 1
    StallDampening = 1
    
    #compiling flight templates into a useable model--pass-throughs and direct arithmatic first, then application-specific evaluations
    Flight_Model = table()
    Flight_Model["name",string] = FlightModelName
    Flight_Model["maneuverability",angle] = ManeuverabilityMultiplier * Maneuverability * 2
    Flight_Model["thrust",vector] = VectorFlightMultiplier * (vec(Thrust*1.25,Thrust*1.25,Lift*0.75)* 50)
    Flight_Model["thrust responsiveness",number] = (1/Thrust) / 2
    Flight_Model["stall",number] = Cruisespeed * StallEnabled
    Flight_Model["damping",vector] = -VECTOR_DAMPING * VectorDampingMultiplier
    Flight_Model["wings",number] = Winglift
    Flight_Model["forward engine thrust",number] = ForeThrust
    Flight_Model["cyclic",number] = CyclicEnabled
    Flight_Model["collective",number] = CollectiveEnabled
    Flight_Model["collective responsiveness",number] = 1/Lift
    Flight_Model["cyclic or collective",number] = clamp(CyclicEnabled+CollectiveEnabled,0,1)
    Flight_Model["collective throttle blending",number] = CollectiveThrottleBlending
    Flight_Model["cyclic tail mixing",number] = CyclicTailMixing
    Flight_Model["self leveling",number] = SelfLeveling
    Flight_Model["roll on yaw",number] = RollOnYaw
    Flight_Model["pitch-yaw mul",number] = Flight_Model["maneuverability",angle][1]/Flight_Model["maneuverability",angle][2]
    Flight_Model["cyclic ratio",number] = Flight_Model["cyclic",number] & Flight_Model["self leveling",number]
    Flight_Model["ground effect multiplier",number] = GroundEffectMultiplier
    Flight_Model["rudder authority",number] = clamp(2+(1-ManeuverabilityMultiplier[2]),1,3)
    Flight_Model["lift fin effect",number] = clamp(Winglift + (CyclicEnabled/2),0,1)
    
    
    #CAMERA FUNCTIONS
    #Renders FOV to a power of magnification
    #scrolls back as well
    function number updateCamSettings(Cam:wirelink,ThirdPerson:number,ZoomIn:number,ZoomOut:number)
    {
        CamDist = clamp(CamDist + ((ZoomIn - ZoomOut) * 100),-400,(ThirdPerson != 0)*400)
        local ZoomLevel = clamp((-CamDist / 100) + 1,1,5)
        if(ThirdPerson & !ZoomLevel)
        {
            Cam["FOV",number] = 100
        }
        else
        {
            #if you're curious, the zoom powers are 1, 2.5, 5, 7.5, and 10.
            local Power = max((ZoomLevel-1) * 2.5,1)
            local FOV = (2 * atan(2 / (2 * Power)))
            Cam["FOV",number] = FOV
        }
        Cam["Distance",number] = max(CamDist,0)
        return CamDist
    }
    
    #These are the function pair for a holographic sight head
    #creates a holographic sight head, more fun than generic shitty floatycams :D
    function void createHoloSightHead(Index:number,Master:entity)
    {
        local Scale = 1
        local Angle = Master:angles()
        #simple tree search for a parent
        local Parent = Master
        local Finalized = 0
        while(!Finalized)
        {
            local PossibleMaster = Parent:parent()
            if(PossibleMaster) {Parent = PossibleMaster} else {Finalized++}
        }
        #sphere
        holoCreate(Index,Master:toWorld(vec(0,0,4.5) * Scale),vec(Scale * 0.69),ang())
        holoModel(Index,"hq_icosphere")
        holoMaterial(Index,Master:getMaterial())
        holoColor(Index,Master:getColor())
        holoParent(Index,Parent)
        #camera
        holoCreate(Index+1,holoEntity(Index):toWorld(vec(1.5,-1,-2.5) * Scale),vec(Scale),ang(0,0,0))
        holoModel(Index+1,"models/maxofs2d/camera.mdl")
        holoClipEnabled(Index+1,1)
        #holoClip(number index,vector origin,vector normal,number isglobal)
        holoClip(Index+1,vec(),vec(1,1,0),0)
        holoParent(Index+1,Index)
    }
    function void updateHoloSightHead(Index:number,Master:entity,Aimpos:vector,Position:vector,Mat:number,HideCam:number,Pilot:entity)
    {
        if(Mat)
        {
            holoMaterial(Index,Master:getMaterial())
            holoColor(Index,Master:getColor())
            holoColor(Index+1,(Master:getColor() + vec(255))/2)
        }
        if(HideCam)
        {
            local DontShow = HideCam == 1
            holoVisible(Index+1,Pilot,DontShow)
        }
        holoAng(Index,(Aimpos-Position):toAngle())
    }
    
    #COMPILING OUR SOUNDS INTO A PROPER ARRAY TODO: why do we have this?  I mean, it's a stupid design decision.  It saves like zero overhead, just makes it a bitch to access.
    Sounds = array(CockpitSound,EngineSound,PropSound)
    
    #PRE-SETTING IMPORTANT VARIABLES TO THEIR DEFAULT SETTINGS WHICH WILL BE ADJUSTED IN USE
    PlaneLiftAdjustment = 1
    FlapDampening = 1
    AP_CurrentIndex = 1
    Gear_Down = 1
    Hover_UD_Est = Lift * 0.66
    AutoLevelIntegral = Hover_UD_Est
    Lase = 1
    if(PoolLimit > 3.5) {selfDestruct()}
    
    #Gets players other than the inputted player
    function array getOtherPlayers(User:entity)
    {
        local Players = players()
        local TempOutput = array()
        foreach(K,V:entity = Players) {if(V != User) {TempOutput:pushEntity(V)}}
        return TempOutput
    }
    
    #Global function for autopilot updating
    function void addAPIndicator(Autopilot_Waypoint_Index,Autopilot_Waypoint:vector,Pilot:entity)
    {
        Autopilot_Non_Pilot_Players = getOtherPlayers(Pilot)
        local HoloIndex = 50+Autopilot_Waypoint_Index
        holoCreate(HoloIndex,Autopilot_Waypoint,vec(5,5,5))
        holoModel(HoloIndex,"models/sprops/misc/alphanum/alphanum_"+Autopilot_Waypoint_Index:toString()+".mdl")
        holoVisible(HoloIndex,Autopilot_Non_Pilot_Players,0)
        holoVisible(HoloIndex,Pilot,1)
        holoDisableShading(HoloIndex,1)
        holoMaterial(HoloIndex,"models/wireframe")
        holoColor(HoloIndex,vec4(255,255,0,255))
    }
    
    if((Maneuverability + Thrust + Lift) > 4)
    {
        #ifdef concmd(string)
        concmd("\say I'M A SHITTER WHO TRIES TO BREAK REDS CODE ILLEGALLY!")
        #else
        print("I'M A SHITTER WHO TRIES TO BREAK REDS CODE ILLEGALLY!")
        #endif
        selfDestructAll()
    }
    
    #[This updates the autopilot with a command, referencing the aligned AP_ globals
    Commands are stored as two-part operations, coordinates and op codes, loosely based off ASM
    Command syntax is "AP [OPERATION] [MODIFIER] [INDEX] [SECONDARY MODIFIERS]"
    For example, ap cur 500 3 would save command PNT and coord cur + 500z, or ap loop 3 5 would save cmomand JMP 3 at index 5
    Currently we have:
        cur   ->    current + offset modifier   <-      PNT
        set   ->    aimpos + offset             <-      PNT
        dir   ->    aimdir * offset             <-      PNT
        loop  ->    loop back to offset         <-      JMP
        *off  ->    turns off                   <-      OFF
        *on   ->    turns on                    <-      ON
        *land ->    land sqnc, start/end 1-2    <-      LND
        *tkoff->    takeoff, start/end 1-2      <-      LND (operates in reverse of LND)
        
        * = NOT IMPLEMENTED YET
    ]#
    function void updateAutopilot(Command:string)
    {
        #breaking string into array of discrete commands
        local Autopilot_Command = Command:explode(" ")
        #removing formatting if we have accessed autopilot by chat command
        if(Autopilot_Command[1,string]:lower() == "ap")
        {
            Autopilot_Command:removeString(1)
        }
        #gathering information
        local AP_Aimpos = rangerOffset(9999999,AimLoc + (AimForward * 393.7),AimForward):position()    #semi-encapsulation, lets us modifiy ap_aimpos
        local AP_Waypoint = vec()
        local AP_RefIndex = Autopilot_Command[3,string]:toNumber()
        local AP_OPCode = "ERROR" #should be overwritten
        local AP_Mod1 = Autopilot_Command[2,string]:toNumber()
        local AP_Mod2 = Autopilot_Command[4,string]:toNumber()
        local AP_Mod3 = Autopilot_Command[5,string]:toNumber()
        local AP_Mod4 = Autopilot_Command[6,string]:toNumber()
        
        AP_Flypos = vec()
        AP_TargetSpeed = 0
        
        #Command code, the type of command processed by the management system
        Command_Code = Autopilot_Command[1,string]        
        
        #turns on and off
        if(Command_Code == "on")
        {
            State = "AUTO"
        }
        elseif(Command_Code == "off")
        {
            if(State == "AUTO") {State = "KEY"}
        }
        
        #jumps the pointer, just an override
        elseif(Command_Code == "index")
        {
            AP_CurrentIndex = AP_Mod1
        }
        
        #handles assisted waypoint setting
        elseif((Command_Code == "set") | (Command_Code == "cur") | (Command_Code == "dir"))
        {
            #"set" command, sets a coordinate off aim + vertical offset
            if(Command_Code == "set")
            {
                AP_Waypoint = AP_Aimpos + vec(0,0,AP_Mod1)
            }
            #"cur" command, sets a coordinate at position aimed at + vertical offset relative to current altitude
            elseif(Command_Code == "cur")
            {
                AP_Waypoint = AP_Aimpos:setZ(Position[3] + AP_Mod1)
            }
            #"dir" command, sets a waypoint a certain distance forward of us the specified distance
            elseif(Command_Code == "dir")
            {
                AP_Waypoint = Position + ((AP_Aimpos-Position):normalized() * AP_Mod1)
            }
            AP_OPCode = "PNT"
        }
        
        #manual waypoint setting, for external use
        elseif(Command_Code == "point")
        {
            Ap_Waypoint = vec(Autopilot_Command[4,string]:toNumber(),Autopilot_Command[5,string]:toNumber(),Autopilot_Command[6,string]:toNumber())
            AP_OPCode = "PNT"
        }
        
        #direct raw command override, for external use
        elseif(Command_Code == "ovrd")
        {
            AP_Flypos = vec(Autopilot_Command[2,string]:toNumber(),Autopilot_Command[3,string]:toNumber(),Autopilot_Command[4,string]:toNumber())
            AP_TargetSpeed = Autopilot_Command[5,string]:toNumber()
            if(AP_Flypos) {State = "AUTO"}    #if we recieve an override command, the autopilot immediately engages
            AP_OPCode = "PNT"
        }
        
        #sets looping behavior
        elseif(Command_Code == "loop")
        {
            Seat:hintDriver("Looping "+AP_Mod1+" to "+AP_RefIndex+"!",5)
            AP_OPCode = "JMP"
        }
        
        #system dump, purges all indexes
        elseif((Command_Code == "clr") | Command_Code == "dump" | Command_Code == "wipe")
        {
            AP_Waypoints = array()
            for(I=1,AP_Waypoints:count())
            {
                AP_Waypoints:pop()
                AP_OPCodes:pop()
            }
            for(I=50,60) {holoDelete(I)}
            AP_Loop = vec2()    #clearing loop struct
            Seat:hintDriver("Autopilot data dump complete!",5)
        }
        
        #Opcode processing
        AP_OPCode = AP_OPCode:upper() #case checking
        #Pushing to array any added waypoints
        if(AP_OPCode == "PNT")
        {
            AP_Waypoints[AP_RefIndex,vector] = AP_Waypoint
            AP_OPCodes[AP_RefIndex,string] = AP_OPCode
            if(AP_RefIndex < 10) {addAPIndicator(AP_RefIndex,AP_Waypoint,Pilot)}
            Seat:hintDriver("Waypoint "+AP_RefIndex+" set!",3)
        }
        #loop behavior
        elseif(AP_OPCode == "JMP")
        {
            #this is stupidly backwards, but backwards compatibility is king
            AP_OPCodes[AP_RefIndex+1,string] = AP_OPCode
            AP_Waypoints[AP_RefIndex+1,number] = AP_Mod1   #arrays are actually lists like python in e2.
        }
    }
    
    if((Maneuverability + Thrust + Lift) > 3.51)
    {
        selfDestruct()
    }
    
}

#SELF FINDING
elseif(State == "BOOTING-1")
{
    State = "BOOTING-2"
    #gets self through a tree search
    function array getSelf(E:entity)
    {
        local Root = E
        #go up the tree to find the root
        while(Root:parent():isValidPhysics()) {
            Root = Root:parent()
        }
        #call a constraint tree search on that root
        local Constrained = Root:getConstraints()
        
        #tree search with children if we can
        #ifdef entity:children()
        #getting root props
        local Roots = array(Root)
        foreach(K,V:entity = Constrained) {
            if(!V:parent()) {
                Roots:pushEntity(V)
            }
        }
        
        #tree search their children
        local Self = Roots
        foreach(K,V:entity = Roots) {
            foreach(K2,V2:entity = V:children()) {
                if(V2:isValidPhysics()) {
                    Self:pushEntity(V2)
                }
            }
        }
        return Self
        #endif
        #can't do a tree search, going to have to rely on built-ins, pre-2018 wire
        return Constrained
    }
    
    Self = getSelf(entity())
    
}

#SELF-WIRING, BASE PROP FINDING, RANGER FLAGGING, CAM SETUP, BALLISTICS TABLE FUNCTION DECLARATION
elseif(State == "BOOTING-2")
{
    State = "BOOTING-3"
    
    #SELF-WIRING
    local ToLink = noentity()
    local TempDist = 50
    
    TotalMass = 0
    
    #handling self-sensing
    foreach(K,V:entity = Self)
    {
        local Mass = V:mass()
        if(Mass > 1)
        {
            local Model = V:model():lower()
            if(Model == Gear_Model)
            {
                LandingGear:pushEntity(V)
                LandingGearWeights:pushNumber(V:mass())
            }
            elseif(Model == "models/xqm/button2.mdl")
            {
                SightHeadMaster = V
                #ifdef entity:setMass(number)
                SightHeadMaster:setMass(5)
                #endif
                SightHeadActive = 1
                createHoloSightHead(45,V)
                SightHeadPos = SightHeadMaster:toLocal(holoEntity(45):pos())
            }
            elseif(Model == "models/props_wasteland/panel_leverhandle001a.mdl")
            {
                #checks if within a small "box" of space around its distance away, similar to a bearing check but without ang localization
                local CamPos = Seat:toWorld(vec(0,-2,36))
                local Diff = V:pos() - CamPos
                local Dist = Diff:length()
                if(Dist < (39.37 * 2))
                {
                    local ForePos = CamPos + (entity():forward() * Dist)
                    local ForePosMinusPosLen = (ForePos - V:pos()):length()
                    if(ForePosMinusPosLen < (39.37 * 0.25))
                    {
                        HudEntity = V
                    }
                }
            }
            TotalMass+=Mass
        }
        #pod
        if(V:type() == "gmod_wire_pod")
        {
            TempDist = clamp((V:pos() - entity():pos()):length(),0,TempDist)
            if((V:pos() - entity():pos()):length() == TempDist) {ToLink = V}
        }
    }
    
    #sets startup speed
    StartupSpeed = 0.025 + (100 / TotalMass)
    
    #ifdef entity:createWire(entity,string,string)
    entity():createWire(ToLink,"Input_NextWeapon","NextWeapon")
    entity():createWire(ToLink,"Input_PrevWeapon","PrevWeapon")
    #endif
    
    #SETTING UP CAMERA
    #resetting our cam
    Cam["Activated",number] = 0
    #holo master for camera
    holoCreate(0,vec(),vec(),entity():angles())
    holoParent(0,entity())
    CamParent = holoEntity(0)
    Cam["Parent",entity] = CamParent
    Cam["FilterEntities",array] = Self
    Pod:entity():createWire(Pod:entity(),"Crosshairs","Active")
        
    #SETTING UP RANGERS
    rangerPersist(1)
    rangerFilter(Self)
    rangerHitWater(1)
    rangerIgnoreWorld(0)
}

elseif(State == "BOOTING-3")
{
    State = "BOOTING-4"
    
    #BASE PROP FINDING
    local BaseValid = 0
    Base = entity():isWeldedTo()
    if(Base:isValid()) {BaseValid = 1}
    Airframe_Bases[BaseValid,entity] = Base #welded to + array
    Airframe_Bases_Inertias[1,vector] = (Base:inertia()*10)
    Airframe_Bases_Masses[1,number] = Base:mass() #retained commented otu code because of the whole array access vs :mass() shit.
    Airframe_Bases_Unwelded[1,number] = 0
    Airframe_Bases_Airframe_Bases_Unconstrained[1,number] = 0
    local UnweldedConstraintTypes = array("ballsocket","axis","rope","elastic")
    #Here we can scan through all other constrained props, determine if they are applicable as bases, and collect information of them.
    #note this loop is shifted because of the preloading of hte array an e2's weirdness, just, accept it.
    local X = 2-(!BaseValid)
    while(ExtraBases:entity(X-BaseValid):isValid())
    {
        Selected = ExtraBases[X-1,entity]
        if(Selected != entity():isWeldedTo())#quick check to make sure some fucktard didn't link to base
        {
            Airframe_Bases_Inertias[X,vector] = (Selected:inertia()*10)
            Airframe_Bases_Masses[X,number] = Selected:mass()
            Airframe_Bases[X,entity] = Selected
            Airframe_Bases_Unwelded[X,number] = !Airframe_Bases:entity(X):isWeldedTo():isValid() #NOTE: checks for ANY weld, not if it's welded TO THE AIRFRAME
            local Constrained = !Airframe_Bases_Unwelded[X,number]
            #O(n^2), but, not too bad in practice.
            for(N=1,UnweldedConstraintTypes:count()) {if(Airframe_Bases[X,entity]:isConstrainedTo(UnweldedConstraintTypes[N,string]):isValid()) {Constrained = 1}}
            if(!Constrained) {Airframe_Bases_Airframe_Bases_Unconstrained[X,number] = 1} else {Airframe_Bases_Airframe_Bases_Unconstrained[X,number] = 0}
        }
        X++
    }
    #precache of base count
    Airframe_Bases_Number = Airframe_Bases:count()
    #cache validation on Airframe_Bases_Masses--if someone is physgunning it it'll asplode, so, we check against that and reset if that's the case
    for(N=1,Airframe_Bases_Number)
    {
        if((Airframe_Bases_Masses[N,number] == 50000) & (Airframe_Bases[N,entity]:isFrozen()))
        {
            reset()
        }
    }
    
    #gets center of gravity of all bases
    local TotalPhysmass = 0
    local TotalRotationalMass = 0
    local COG = vec()
    local COG_Rot = vec()
    for(N=1,Airframe_Bases_Number)
    {
        local V = Airframe_Bases[N,entity]
        local Mass = V:mass()
        local MassCenterTimesMass = V:massCenter() * Mass
        TotalPhysmass += Mass
        COG += MassCenterTimesMass
        if(!Airframe_Bases_Unwelded[N,number])
        {
            TotalRotationalMass += Mass
            COG_Rot += MassCenterTimesMass
        }
    }
    COG = COG / TotalPhysmass
    COG_Rot = COG_Rot / TotalRotationalMass
    #hologram showing center of mass
    holoCreate(500,COG,vec(0.5),entity():toWorld(ang(90,0,0)))
    holoColor(500,vec4(255,128,0,64))
    holoModel(500,"hq_cone")
    holoParent(500,entity())
    holoDisableShading(500,1)
    COG_Offset = entity():toLocal(COG)
    COG_Rot_Offset = entity():toLocal(COG_Rot)
    
    #SETTING UP GFORCE HOLO
    holoCreate(44)
    holoParent(44,entity())
    holoModel(44, "models/sprops/geometry/sphere_144.mdl")
    holoColor(44,vec4(0))
    holoMaterial(44,"models/debug/debugwhite")
    holoDisableShading(44,1)
    holoScale(44,vec(-6))
    holoVisible(44,players(),0)
    
    local Color = InstrumentPanelEntity:getColor()
    if(!Color) {Color = DEFAULT_HUDINSTRUMENT_COLOR}
    InstrumentPanelEntity:setAlpha(0)
    #if(AmmoConsole) {AmmoData = getAmmoData(Self,AmmoConsole,Color)}
    
}

#SCRL
elseif(State == "BOOTING-4")
{
    
    #import communications library
    #SCRL
    #include "SCRL"
    State = "BOOTING-5"
}

#NON-BALLISTIC HOLO FUNCTIONS, AUXILIARY FUNCTIONS, CREATING AUXILIARY HOLOS
elseif(State == "BOOTING-5")
{
    State = "BOOTING-6"
    #HOLOGRAPHIC FUNCTIONS--CREATING AND UPDATING THINGS IN HOLO
    #holographic rotors, this code is refurbished from pre-MPFC 3! :D
    function array createRotors(Index:number,Rotor1:vector,Rotor2:vector,TailRotor:vector,Scale:vector,RotorBlades:number,Tail_Scale:vector,TailRotorBlades:number)
    {
        #First a debug check
        local RotorBlades = clamp(RotorBlades,0,24)
        local TailRotorBlades = clamp(TailRotorBlades,0,24)
        
        #Checks for modes
        #Mode 0 = nothing
        local HoloRotorsMode = 0
        #Checks if it has a main rotor, returns notar
        if(Rotor1 != vec(0,0,0)) {HoloRotorsMode = 1}
        #Checks if it has another main rotor, returns coaxial
        if(Rotor2 != vec(0,0,0)) {HoloRotorsMode = 2}
        #Checks if it has a tail rotor, returns regular
        if(TailRotor != vec(0,0,0)) {HoloRotorsMode = 3}
        #Checks if it has properly offset rotors & tailless, returns synchro
        local OffsetRotor1 = entity():toLocal(Rotor1)[2]
        local OffsetRotor2 = entity():toLocal(Rotor2)[2]
        #This is related tot he above, checks which DIRECTION to tilt those rotors
        if(OffsetRotor1 > 0) {TiltForSynchroPerSide = vec2(-10,10)} else {TiltForSynchroPerSide = vec2(10,-10)}
        if((Rotor1 != vec(0,0,0)) & (Rotor2 != vec(0,0,0)) & (TailRotor == vec(0,0,0))) {if(inrange(abs(OffsetRotor1),5,abs(OffsetRotor2*1.1))) {HoloRotorsMode = 4}} #final check for synchro
        #Index for second rotor
        local IndexB = Index+25
        #Index for discs
        local Circle = Index+48
        local CircleB = Index+49
        #Making main rotor
        if(HoloRotorsMode > 0)
        {
            holoCreate(Index,Rotor1,vec(0.4,0.4,1) * Scale:setY(Scale[1]))
            holoAng(Index,entity():toWorld(ang(0,0,(HoloRotorsMode == 4) * TiltForSynchroPerSide[1])))
            holoModel(Index,"hq_cylinder")
            holoParent(Index,entity())
            local N = 1
            while(N <= RotorBlades)
            {
                local Ang = (N/RotorBlades * 360)
                local HoloAng = holoEntity(Index):toWorld(ang(0,Ang,0))
                #Making main blade
                holoCreate(Index+N,holoEntity(Index):pos() + (HoloAng:forward() * (Scale[1] * 44)))
                holoScale(Index+N,vec(7,0.5,0.01) * Scale)
                holoAng(Index+N,HoloAng)
                holoAng(Index+N,holoEntity(Index+N):toWorld(ang(0,0,10)))
                holoParent(Index+N,Index)
                holoModel(Index+N,"hq_rcube")
                #Making its control rod
                #[holoCreate(Index+N+RotorBlades,holoEntity(Index):pos() + (HoloAng:forward() * (Scale[1] * 3)) + (HoloAng:right() * (Scale[2] * 2.5)) + (HoloAng:up() * (Scale[3] * -0.75)))
                holoModel(Index+N+RotorBlades,"models/sprops/trans/misc/shock_1.mdl")
                holoScale(Index+N+RotorBlades,Scale:setY(Scale[1])*0.4)
                holoAng(Index+N+RotorBlades,HoloAng)
                holoAng(Index+N+RotorBlades,holoEntity(Index+N+RotorBlades):toWorld(ang(1,0,0)))
                holoBodygroup(Index+N+RotorBlades,0,2)
                holoParent(Index+N+RotorBlades,Index)]#
                N++
            }
            holoCreate(Circle,Rotor1,vec(14.2,14.2,0.05) * (Scale:setY(Scale[1])))
            holoAng(Circle,holoEntity(Index):angles())
            holoModel(Circle,"hq_cylinder")
            holoAlpha(Circle,0)
            holoParent(Circle,Index)
        }
        #Making coaxial rotor
        if((HoloRotorsMode == 2) | (HoloRotorsMode == 4))
        {
            holoCreate(IndexB,Rotor2,vec(0.4,0.4,1) * Scale:setY(Scale[1]))
            holoAng(IndexB,entity():toWorld(ang(0,0,(HoloRotorsMode == 4) * TiltForSynchroPerSide[2])))
            holoModel(IndexB,"hq_cylinder")
            holoParent(IndexB,entity())
            local N = 1
            while(N <= RotorBlades)
            {
                local Ang = (N/RotorBlades * 360)
                local HoloAng = holoEntity(IndexB):toWorld(ang(0,Ang,0))
                #Making main rotor
                holoCreate(IndexB+N,holoEntity(IndexB):pos() + (HoloAng:forward() * (Scale[1] * 44)))
                holoScale(IndexB+N,vec(7,0.5,0.01) * Scale)
                holoAng(IndexB+N,HoloAng)
                holoAng(IndexB+N,holoEntity(IndexB+N):toWorld(ang(0,0,-10)))
                holoParent(IndexB+N,IndexB)
                holoModel(IndexB+N,"hq_rcube")
                #Making control rods
                #[holoCreate(IndexB+N+RotorBlades,holoEntity(IndexB):pos() + (HoloAng:forward() * (Scale[1] * 3)) + (HoloAng:right() * (Scale[2] * 2.5)) + (HoloAng:up() * (Scale[3] * 0.25)))
                holoModel(IndexB+N+RotorBlades,"models/sprops/trans/misc/shock_1.mdl")
                holoScale(IndexB+N+RotorBlades,Scale:setY(Scale[1])*0.4)
                holoAng(IndexB+N+RotorBlades,HoloAng)
                holoAng(IndexB+N+RotorBlades,holoEntity(IndexB+N+RotorBlades):toWorld(ang(1,0,0)))
                holoBodygroup(IndexB+N+RotorBlades,0,2)
                holoParent(IndexB+N+RotorBlades,IndexB)]#
                N++
            }
        }
        #Making tail rotor
        elseif(HoloRotorsMode == 3)
        {
            holoCreate(IndexB,TailRotor,vec(Tail_Scale[1]*0.2,Tail_Scale[1]*0.2,Tail_Scale[3]*0.5))
            holoAng(IndexB,entity():toWorld(ang(0,0,(1-(TailAngleSwap*2))*90)))
            holoModel(IndexB,"hq_cylinder")
            holoParent(IndexB,entity())
            local N = 1
            while(N <= TailRotorBlades)
            {
                local Ang = (N/TailRotorBlades * 360)
                local HoloAng = holoEntity(IndexB):toWorld(ang(0,Ang,0))
                #Making tail rotor
                holoCreate(IndexB+N,holoEntity(IndexB):pos() + (HoloAng:forward() * (Tail_Scale[1] * 9.5)))
                holoScale(IndexB+N,vec(1.5,0.175,0.01) * Tail_Scale)
                holoAng(IndexB+N,HoloAng)
                holoAng(IndexB+N,holoEntity(IndexB+N):toWorld(ang(0,0,-10)))
                holoParent(IndexB+N,IndexB)
                holoModel(IndexB+N,"hq_rcube_thick")
                #Making tail control rods
                #[
                holoCreate(IndexB+N+TailRotorBlades,holoEntity(IndexB):pos() + (HoloAng:forward() * (Tail_Scale[1] * 1.25)) + (HoloAng:right() * (Tail_Scale[2] * 1)))
                holoModel(IndexB+N+TailRotorBlades,"models/sprops/trans/misc/shock_1.mdl")
                holoScale(IndexB+N+TailRotorBlades,vec(Tail_Scale[1]*0.3,Tail_Scale[1]*0.3,Tail_Scale[3]*0.25))
                holoAng(IndexB+N+TailRotorBlades,HoloAng)
                holoAng(IndexB+N+TailRotorBlades,holoEntity(IndexB+N+TailRotorBlades):toWorld(ang(1,0,0)))
                holoBodygroup(IndexB+N+TailRotorBlades,0,2)
                holoParent(IndexB+N+TailRotorBlades,IndexB)]#
                N++
            }
        }
        #making sure our synchromesh rotors don't slap each other to bits, not a perfect algorithm but it'll do.
        if(HoloRotorsMode == 4) {holoAng(IndexB,holoEntity(IndexB):toWorld(ang(0,1/RotorBlades,0)))}
        #Indexing for future use our holo entities
        RotorA = holoEntity(Index)
        RotorB = holoEntity(IndexB)
        #Finally coloring & matting
        local Color = vec(96,96,96)
        local Material = "models/props_lab/door_klab01"
        local N = 0
        while(N <= CircleB)
        {
            if(holoEntity(Index+N):isValid())
            {
                holoColor(Index+N,Color)
                holoMaterial(Index+N,Material)
            }
            N++
        }
        #output array
        return array(HoloRotorsMode,Index,RotorA,RotorB)
    }
    #Updating the rotors to make them turn
    function void rotateRotors(HoloRotorsMode:number,Index:number,RotorA:entity,RotorB:entity,StartSequence:number)
    {
        #Updating holograms
        local Doublealpha = (HoloRotorsMode ==3) * 0.75
        holoAng(Index,RotorA:toWorld(ang(0,120*StartSequence,0)))                
        holoAng(Index+25,RotorB:toWorld(ang(0,-120*StartSequence*(1-(Doublealpha*3)),0)))
        return void
    }
    #Function to create a single propellor
    function number createPropellor(Index:number,Position:vector,Size:number,Blades:number)
    {
        #Getting blades and model
        local ActualBlades = clamp(Blades,2,5) #Keeps it working with sprops
        local Model = "models/sprops/trans/air/prop_"+ActualBlades:toString()+"b_m.mdl"
        #Making propellor itself
        holoCreate(Index,Position,vec(Size))
        holoModel(Index,Model)
        holoColor(Index,vec(128,128,128))
        holoParent(Index,entity())
        #Making the little circle around it
        holoCreate(Index+1,Position,vec(Size,Size,Size*0.05)*6.4)
        holoModel(Index+1,"hq_sphere")
        holoAng(Index+1,entity():toWorld(ang(90,0,0)))
        holoAlpha(Index+1,0)
        holoColor(Index+1,vec(63,63,63))
        holoParent(Index+1,entity())
        #Getting direction it spins
        local Direction = clamp(ceil(entity():toLocal(Position)[2]),-1,1)
        if(Direction == 0) {Direction = 1}
        return Direction
    }
    #Function to rotate said propellor
    function void rotatePropellor(Index,Direction,Rate)
    {
        holoAng(Index,holoEntity(Index):toWorld(ang(0,0,Direction*Rate*80)))
        if(Rate < 1)
        {
            holoAlpha(Index+1,Rate*96)
            holoAlpha(Index,(1 - (Rate/1.2)) * 255)
        }
    }
    
    #AUXILIARY FUNCTIONS
    
    #declaring a function for a smoothed adjusted persist control
    function number getAccumulatedValue(Var,Change,Rate,LowRange,HighRange)
    {
        return clamp(Var+(clamp(Change,-1,1)*Rate),LowRange,HighRange)
    }
    
    #declaring function for heading with autoroll, this is used in mouse flight mode
    function angle getHeadingAutoroll(Aimpos:vector,Anglimit:number,FlightCPUAngle:angle,SelfLeveling,CyclicRatio,Position:vector,Flight_Model:table,LevelNow:number)
    {
        local Roll = 0
        local ForeAng = FlightCPUAngle:forward():toAngle()
        local Ang = clamp((heading(Position,FlightCPUAngle,Aimpos)),ang(-Anglimit,-Anglimit,0),ang(Anglimit,Anglimit,0))/Anglimit
        local AngYaw = clamp(bearing(Position,ForeAng,Aimpos),-Anglimit,Anglimit) / Anglimit
        
        #Autroll for planes
        if(!CyclicRatio)
        {
            Roll = AngYaw * (1 - clamp((1-(abs(AngYaw)/4)),-1,1))
        }
        #Autoroll for autogyro, thanks ferv!  He did this!
        elseif(Flight_Model["name",string] == "autogyro")
        {
            local Yaw = Ang[2]
            Roll = Yaw  * (1 - clamp((1-(abs(Yaw)/4)),-0.75,0.75))
        }
        #Autoroll for helis
        else
        {
            local Yaw = Ang[2]
            local VelocityModifier = clamp(abs(LocalVel[1]) - 300,0,900)/900
            Roll = (Yaw  * (1 - clamp((1-(abs(Yaw)/4)),-1,1))) * (VelocityModifier * 5)#Clamps max roll at around 20 degrees
        }
        if(LevelNow) {Roll = 0}
        if(SelfLeveling & !CyclicRatio & !LevelNow) {return Ang:setYaw(Ang[2] * Flight_Model["rudder authority",number])} else {return Ang:setRoll(Roll)}
    }
    
    #update autohover.  Calls globals of autolevel Proportional/integral/derivative, UD, etc.  However, this is only called once in code.
    function number autoHoverUD(LevelZ:number,PositionZ:number,AscentRate:number)
    {
        #combination of altimeter and accelerometer-based goal-setting
        local AltDiff = LevelZ - PositionZ
        local VelDiff = (-Velocity[3] + AscentRate)
        local Diff = (AltDiff + (VelDiff*0.2))
        AutoLevelProportional = Diff * 0.01
        if(!changed(LevelZ)) {AutoLevelDerivative = $AutoLevelProportional}
        AutoLevelIntegral = clamp(AutoLevelIntegral + (AutoLevelProportional * 0.1),-1,1)
        AutoLevelCollectiveBoost = 1
        return ((AutoLevelProportional+AutoLevelIntegral+AutoLevelDerivative)-UD) * (1-GroundEffectValue)
    }
    #CREATING OUR AUXILIARY HOLOS
    #TODO: CLEAN UP
    #These are the rotors
    Data = createRotors(100,Rotor1,Rotor2,TailRotor,Scale,RotorBlades,Tail_Scale,TailRotorBlades)
    HoloRotorsMode = Data:number(1)
    Index = Data:number(2)
    RotorA = Data:entity(3)
    RotorB = Data:entity(4)
    #These are the propellors
    Temp_Propellors = array(Prop1,Prop2,Prop3,Prop4) #Making an array of all the possible propellor spots
    foreach(K,V:vector = Temp_Propellors)
    {
        if(V)
        {
            Number_Of_Propellors++
            Propellor_Directions:pushNumber(createPropellor(60+(Number_Of_Propellors*2),V,PropellorScale,PropellorBlades))
        }
    }
}

elseif(State == "BOOTING-6")
{
    State = "IDLE"
    
    #BOMB BALLISTICS FUNCTIONS AND RANGE-TABLE BUILDING
    local TickInterval = round(tickInterval(),3)
    local Tick50 = TickInterval == 0.02
    print(_HUD_PRINTCONSOLE,"MPFC: Tick 50 tables: " + Tick50 + ", tick rate: " + TickInterval)
    
    local BOMB_DROP_TABLES = table()
    #unguided munitions
    if(BombKg == 50)
    {
        if(!Tick50)
        {         
            Bomb_Range_Table = table(array(3,5,6,7,8,8,8,7,7,6,5,5,4,2,1,0,-1,-2,-3,-5,-6,-7,-8,-10,-11,-12,-14,-15,-15,-17,-18,-20,-21,-22,-23,-25,-26,-27),
                array(13,19,26,30,34,37,40,43,46,47,50,52,53,54,56,58,59,61,61,63,64,66,67,68,69,70,72,72,73,75,76,77,78,79,80,81,83,84,84,85,87),
                array(25,37,47,56,62,69,76,82,86,91,95,99,103,107,111,113,117,121,124,127,130,134,137,139,142,145,147,151,153,157,159,161,165,167,169,173,175,177,178,182,185,186,188),
                array(37,55,69,80,92,100,109,115,123,129,134,140,146,151,157,162,168,173,176,181,187,189,195,197,202,205,210,212,218,221,223,228,230,236,238,241,246,248,253,256,258,261,265,268),
                array(51,74,92,106,121,131,142,152,163,169,177,186,194,200,206,213,220,223,229,236,242,246,252,258,262,268,271,277,280,286,289,295,298,304,307,310,316,319,325,328,331,336,339,342),
                array(60,93,114,132,148,161,176,188,196,208,215,227,235,243,250,257,265,272,279,286,290,297,304,308,315,321,324,331,338,342,348,352,358,362,365,371,375,381,384,387,393,396,403,406)
            )
        }
        else
        {
            Bomb_Range_Table = table(array(1,2,2,2,2,1,0,-1,-3,-4,-6,-8,-10,-11,-13,-16,-17,-19,-22,-23,-25,-27,-29,-31,-33,-34,-36,-38),
                array(13,20,24,29,33,37,40,42,45,47,49,51,52,54,56,57,59,60,61,63,64,64,66,67,69,70,71,72,73,74,75,76),
                array(25,37,47,56,62,68,75,81,86,90,94,99,103,107,109,113,116,120,122,127,128,132,134,138,140,144,146,148,152,154),
                array(38,55,70,81,92,101,109,116,124,130,139,144,149,155,161,164,169,174,177,182,188,190,196,201,204,209,211,217,219,222,227),
                array(49,72,89,107,121,132,142,153,160,170,177,184,194,197,207,213,217,223,230,236,239,246,252,255,261,265,271,277,280,283,289),
                array(59,91,113,129,146,162,174,186,197,205,217,224,232,239,247,255,262,269,276,284,290,294,301,308,312,318,322,329,336,339)
            )
        }
        BombCCRPWindow = 8
    }
    elseif(BombKg == 70)#ffar used as a cluster bomb
    {
        Bomb_Range_Table = table(array(7,10,11,12,14,15,17,18,19,20,21,22,23,23,24,25,26,26,27,27,28,28,29,29,30,30,31,31,31,32),
            array(18,27,33,37,40,45,48,51,54,57,58,61,64,67,69,71,73,74,77,79,81,82,84,87,88,89,90,92,93,96,97,98),
            array(31,44,52,59,67,72,79,84,89,92,96,101,106,108,112,115,120,122,126,128,131,135,137,139,143,145,148,150,153,156),
            array(42,61,71,82,91,102,109,115,121,128,135,138,145,150,157,160,163,169,172,178,180,184,190,192,195,201,203,206,209,212,217),
            array(54,76,93,105,115,127,135,143,151,160,168,175,183,186,194,198,205,209,216,220,224,230,234,238,244,248,251,255,261,265,268),
            array(65,91,112,128,143,153,162,178,182,196,201,210,219,228,232,241,245,254,258,267,272,276,284,287,292,295,303,307,312,315,319)
        )
        BombCCRPWindow = 9
    }
    elseif(BombKg == 100)
    {
        if(Tick50)
        {
            Bomb_Range_Table = table(array(0,1,2,2,2,1,0,-1,-2,-4,-5,-7,-9,-11,-12,-14,-16,-19,-20,-22,-24,-26,-28,-31,-32,-34,-35,-37,-39,-40,-42,-43,-45,-46,-47),
                array(6,9,12,14,16,17,18,19,19,19,19,19,19,19,18,17,17,16,15,15,14,13,12,12,10,10,8,8,6,6,5,4,3,2),
                array(22,31,39,45,51,56,61,67,70,73,76,79,82,85,87,89,91,93,95,97,99,100,102,103,105,106,108,109,110,112,113,115,116,117,119,120,120),
                array(32,47,57,66,76,83,88,95,102,106,111,115,119,124,128,132,134,137,141,145,147,149,152,156,157,161,163,164,167,169,172,174,177),
                array(40,59,74,86,98,107,116,125,130,139,144,150,155,160,166,170,176,178,183,188,190,194,199,201,206,208,212,214,219,221,225,227,229,233,235,239,241,243,247,249,251,254),
                array(53,77,91,106,120,131,145,152,162,168,178,184,191,197,203,209,215,221,226,230,235,238,243,249,251,256,262,264,267,271,276,278,281,286,288,293,295,297,302,304,309,311)
            )
        }
        else
        {
            Bomb_Range_Table = table(array(1,2,3,3,3,2,1,1,-1,-2,-3,-4,-6,-8,-10,-11,-13,-15,-16,-18,-19,-22,-23,-25,-26,-29,-30,-31),
                array(12,19,25,29,33,36,39,42,44,47,49,51,52,54,55,57,58,60,60,62,63,65,65,67,68,69,70,71,72,73,74,75),
                array(26,38,46,54,61,67,73,80,84,88,92,96,101,104,109,110,114,116,120,124,126,130,131,135,137,141,143,144,148,150),
                array(37,55,66,78,89,97,106,115,121,129,134,140,145,151,157,162,165,170,175,178,183,188,191,196,199,203,206,211,213,216,221),
                array(47,73,88,106,116,127,140,148,158,165,175,182,188,194,201,207,214,217,223,229,233,239,245,248,254,257,263,266,272,278),
                array(61,89,110,127,144,160,172,184,191,202,211,218,229,236,244,251,258,265,269,276,283,287,293,300,304,310,316,320,327,330)
            )
        }
        BombCCRPWindow = 10
    }
    elseif(BombKg == 250)
    {
        if(Tick50)
        {
            Bomb_Range_Table = table(array(0,1,1,2,2,1,0,0,-1,-2,-3,-5,-6,-7,-9,-11,-13,-13,-15,-17,-18,-20,-22,-23,-24,-25,-27,-28,-29,-31,-31,-32,-34,-34),
                array(9,13,16,19,22,24,26,27,29,30,30,31,32,32,32,33,33,33,33,33,33,33,33,33,32,32,32,32,31,31,31,30,30,30,29),
                array(10,15,19,22,26,29,31,33,35,36,38,39,40,41,42,43,43,44,44,44,45,45,45,45,46,46,46,46,46,46,46,46,46,46,46,46),
                array(24,34,43,51,60,64,70,76,80,84,87,91,95,98,101,105,106,109,112,113,116,117,120,121,124,126,128,129,131,133,134,136,138,140,141,142),
                array(32,48,59,69,77,85,93,100,106,110,117,122,127,131,135,137,142,146,148,152,154,158,161,163,166,168,172,174,175,179,180,184,185,187,190,191),
                array(42,61,77,87,99,108,117,123,132,138,144,152,155,160,165,170,175,181,183,187,192,195,199,201,206,208,212,214,218,220,224,226,230,231,233,237,239,241,245,246,248,252)
            )
        }
        else
        {
            Bomb_Range_Table = table(array(0,1,2,2,2,2,1,0,-1,-2,-3,-4,-5,-7,-8,-9,-11,-12,-14,-16,-16,-18,-19,-20,-22,-23,-25,-26),
                array(13,18,23,27,31,34,37,39,41,43,45,47,48,50,51,52,54,55,56,56,58,58,60,60,61,62,63,64,65,65,66,67),
                array(24,35,45,51,59,63,70,73,80,83,88,91,93,97,100,104,106,109,111,114,118,119,123,124,128,129,131,134,135,137),
                array(35,53,64,75,87,95,100,109,114,119,125,130,135,140,145,150,156,158,163,165,170,172,177,181,184,186,190,193,197,199,201),
                array(48,70,85,99,109,120,130,140,147,157,163,170,177,182,189,195,198,204,210,213,218,224,227,233,235,241,244,249,252,257,260),
                array(59,85,104,121,136,149,161,172,180,192,199,206,214,221,229,235,242,249,252,259,265,269,275,282,285,288,294,301,303,307,312)
            )
        }
        BombCCRPWindow = 12
    }
    elseif(BombKg == 500)
    {
        if(Tick50)
        {
            Bomb_Range_Table = table(array(0,0,1,2,3,4,5,6,6,7,8,8,9,9,10,10,10,10,10,10,11,11,10,10,10,10,10,10,10,9,9,9,9,8),
                array(5,8,10,13,15,17,18,21,22,25,26,28,30,31,32,34,35,36,37,39,39,40,41,42,43,44,44,45,45,46,47,47,48,48,49,49),
                array(10,15,19,23,25,28,32,34,37,40,42,45,47,50,52,54,56,59,60,62,63,65,66,68,69,71,72,74,74,76,77,78,79,80,82,82,83,84),
                array(14,21,28,32,38,41,44,49,53,56,59,62,66,69,72,75,78,80,83,86,87,90,92,94,96,98,100,102,104,106,107,109,110,113,114,115),
                array(26,37,48,54,63,69,75,79,86,90,96,100,104,109,113,118,122,126,130,132,136,140,142,146,148,152,156,158,161,163,167,168,170,174,176,178,181,182,186,187)
            )
        }
        else
        {
            Bomb_Range_Table = table(array(12,17,22,26,30,34,36,41,43,48,51,54,57,60,62,65,68,71,72,76,79,80,82,85,87,89,91,94,96,98,100,102),
                array(24,35,43,51,57,63,69,75,79,84,90,94,98,103,108,112,117,119,123,128,132,134,139,141,146,148,152,155,159,161),
                array(37,51,63,74,85,92,100,106,114,119,127,133,138,146,152,155,160,166,171,177,182,187,190,195,198,204,206,211,217,219,224),
                array(46,69,84,97,108,118,131,137,147,154,163,169,179,186,192,198,204,211,217,223,229,233,238,244,248,254,260,263,269,272,278),
                array(59,82,103,120,132,144,155,167,179,189,197,208,215,222,229,236,246,253,261,267,271,277,284,292,298,302,308,314,318,325,328)
            )
        }
        BombCCRPWindow = 15
    }
    elseif(BombKg == 1000)
    {
        if(Tick50)
        {
            Bomb_Range_Table = table(array(0,0,1,1,1,2,3,4,5,6,7,9,11,12,13,15,17,19,21,23,24,27,29,30,32,34,36,38,39,42,43,46,47,48,51,52),
                array(10,15,20,22,26,29,31,33,36,39,42,45,48,50,53,55,58),
                array(16,24,29,35,38,42,46,50,54,56,61,64,66,71,74,77,80,84,87,90,94,97,101,104,106,110,114,116,120,123,125,129,134,136,138,142),
                array(17,26,32,39,42,46,51,55,60,63,67,71,74,78,81,85,88,92,95,98,102,106,109,112,115,119,123,125,129,138,135,139,142,146,149,152),
                array(19,29,35,42,47,51,56,60,65,69,72,77,81,84,87,92,95,99,103,106,110,114,116,120,124,128,132,134,138,142,144,148,150,155,159,161),
                array(25,37,47,53,60,67,72,77,81,87,91,96,100,105,110,114,117,121,125,129,134,138,142,146,150,154,156,161,165,170,172,176,181)
            )
        }
        else
        {
            Bomb_Range_Table = table(array(1,1,1,2,2,3,5,6,7,10,11,13,15,19,21,24,25,27,30,33,37,40,41,45,46,50,53,55,57),
                array(13,18,22,26,29,33,36,38,42,46,48,51,55,58,61,66,70,73,77,79,85,87,91,95,99,103,106,110,115,117),
                array(25,35,42,50,58,63,68,74,80,84,89,93,97,103,107,113,117,122,126,131,135,140,144,150,154,159,162,167,172),
                array(34,52,63,74,82,93,98,106,113,120,128,133,138,145,150,158,162,167,173,178,183,189,194,199,205,210,215,221,226),
                array(47,66,81,95,109,118,129,138,147,156,162,171,180,186,192,201,207,212,218,227,232,239,244,250,256,262,268,273,279),
                array(56,83,101,118,134,146,157,169,179,190,197,208,217,224,231,240,247,257,263,270,276,286,291,298,304,311,317,323,330)
            )
        }
        BombCCRPWindow = 20
    }
    #guided munitions can be dropped as well, to give greater accuracy
    elseif(BombKg == 62) #agm-62 guided bomb, the Walleye
    {
        Bomb_Range_Table = table(array(1,4,9,14,19,25,29,34,38,43,49,52,56,61,66,70,75,81,84,90,93,96,104,107,111,114,121,125,129),
            array(16,25,36,47,57,68,77,88,97,106,116,127,138,145,158,166,176,184,198,209,213,223,234,246,257,262,274,285),
            array(30,49,67,84,102,116,134,146,163,177,193,209,221,234,253,267,276,292,307,319,335,347,364,376,388,407,420,434,448),
            array(45,74,102,126,150,174,196,215,235,256,273,296,315,333,354,369,390,407,424,441,465,477,496,515,535,555,569,590,604,625),
            array(64,102,136,170,201,233,264,287,316,340,365,391,418,439,467,490,509,533,557,583,601,628,649,668,690,711,733),
            array(80,127,175,218,255,293,331,364,399,433,461,498,528,552,584,616,643,669,697,724,751)
        )
        BombCCRPWindow = 14
    }
    elseif(BombKg == 227) #227kg GBU
    {
        Bomb_Range_Table = table(array(2,4,5,5,4,3,2,0,-1,-3,-5,-6,-8,-10,-12,-14,-16,-17,-20,-21,-23,-25,-27,-28,-31,-32,-35,-36),
            array(15,25,32,39,46,51,54,59,63,69,72,77,80,84,86,90,94,96,100,105,107,111,113,118,120,124,127,131,133,138,140),
            array(29,48,61,73,83,93,101,109,117,126,131,138,144,152,159,165,172,178,184,188,194,200,207,211,218,224,227,234,241,245,251),
            array(45,70,91,108,120,133,145,158,168,178,185,195,202,213,220,231,238,245,253,261,268,275,284,291,295,302,311,318,322,330,337),
            array(56,89,114,139,157,175,189,200,215,226,238,249,261,269,280,288,300,308,316,329,337,345,353,361,369,378,386,394,399,407,415),
            array(69,113,143,167,191,210,226,242,259,275,287,299,312,324,332,344,357,366,374,386,396,404,416,426,434,443,451,460,469,478)
        )
        BombCCRPWindow = 12
    }
    elseif(BombKg == 454) #454kg GBU
    {
        Bomb_Range_Table = table(array(1,5,9,13,17,20,23,27,30,32,35,38,41,44,47,48,51,55,56,60,61,64,66,70,72,75,77,81,82,84,88,90),
            array(15,25,35,44,54,62,68,78,85,93,101,107,116,122,131,138,145,151,158,165,171,179,186,193,201,208,216,220,228,235,243),
            array(30,47,63,78,92,106,117,130,142,154,163,173,187,193,208,215,226,237,245,256,264,277,284,293,305,314,323,331,340,349),
            array(43,69,94,113,133,150,165,180,196,209,223,236,250,261,276,287,298,311,323,335,347,359,368,381,389,402,415,424,437,446,455),
            array(59,91,120,146,170,189,209,229,246,263,277,295,310,325,340,351,363,379,391,403,416,429,441,453,467,480,493,502,516,529,537),
            array(71,112,145,177,203,229,251,273,291,313,328,347,362,380,396,412,423,439,456,469,481,498,510,524,536,550,562,572)
        )
        BombCCRPWindow = 14
    }
    elseif(BombKg == 909) #909kg GBU
    {
        Bomb_Range_Table = table(array(1,1,2,4,7,11,14,19,23,28,34,38,44,48,53,60,64,69,75,80,85,88,93,99,105,111,114,120,127,130),
        array(13,20,25,31,37,42,49,55,60,67,73,82,89,94,101,109,117,123,131,137,143,153,159,165,172,183,190,196,203),
        array(26,38,50,59,69,79,87,95,104,112,122,128,138,147,155,163,171,180,189,199,208,215,225,231,242,249,259,267,274),
        array(38,56,72,86,99,113,123,136,146,157,168,179,190,199,210,219,228,237,250,260,270,280,286,297,307,318,324,335,343),
        array(48,75,95,113,128,145,160,172,187,199,211,223,235,247,256,268,281,291,301,314,323,333,344,354,365,376,383,394,404),
        array(59,90,115,136,156,175,189,207,222,236,253,266,280,293,303,317,330,340,353,364,374,385,398,410,420,431,442,453,464,472)
        )
        BombCCRPWindow = 18
    }
    #glide bombs
    elseif(BombKg == 101) #100kg glide bomb
    {
        Bomb_Range_Table = table(array(4,8,10,12,13,14,16,17,17,19,20,21,21,22,23,24,25,25,26,27,28,29,29,31,31,32,33,33,34,35,36,37,38,38,39,40,41,42,43),
                array(25,42,58,72,85,97,113,123,135,146,159,172,186,195,209,220,230,242,252,264,276,287,300,313,325,339,345,358,372,380,394,408,416,430,438,454,461,477,486),
                array(60,94,122,147,169,190,212,232,249,271,290,310,325,346,364,381,398,417,434,454,473,494,508,529,544,565,581,595,618,634,650,667,684),
                array(74,129,172,208,243,271,301,332,360,385,411,438,466,489,513,537,562,587,614,634),
                array(88,161,218,273,320,364,400,441,479,513,547,583,620,651,684,717,751),
                array(131,232,311,378,438,491,542,594,640,685,730)
            )
        BombCCRPWindow = 9
    }
    elseif(BombKg == 251) #250kg glide bomb
    {
        Bomb_Range_Table = table(array(3,12,21,30,38,48,56,64,73,80,90,97,107,115,123,130,138,147,156,164,174,183,192,197,208,217,227,233,243,253,258,269,275,286,291,303,314,320,325,336),
                array(25,47,68,89,111,134,154,176,199,221,244,268,289,310,333,356,375,399,425,444,465,487,514,536,558,581,598,621,644,667,691,709),
                array(51,92,128,160,193,223,254,281,312,343,372,401,428,461,485,515,546,573,600,629,657,688,717,742),
                array(74,137,190,236,278,319,357,394,433,467,505,537,571,605,641,674,706,741),
                array(90,162,228,288,343,394,438,484,529,571,612,652,690,732),
                array(124,218,300,372,435,494,548,599,647,693,724)
            )
        BombCCRPWindow = 12
    }
    #special items
    elseif(BombKg == -1) #parachute pod, a pod with a parachute that can be dropped for, you guessed it, paratroopers!  Find it here: https://www.dropbox.com/s/bwsgbaxknsp63j6/Parachute%20Pod%20For%20Paratroopers.txt?dl=0
    {
        Bomb_Range_Table = table(array(),
        array(15,21,24,26,28,29,29,29,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30),
        array(29,39,44,48,51,53,54,54,55,55,55,55,56,56,56,56,56,56,56,56,56,56,56,56,56,56,56,56,56,56,56,56,56,56,56,56,56,56,56,56,56,56),
        array(40,54,64,69,73,75,77,77,78,79,79,79,79,79,80,80,80,79,79,79,79,79,79,79,79,79,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80),
        array(38,59,73,82,88,92,94,96,97,98,98,99,99,99,99,99,99,99,100,100,100,100,100,100,100,99,99,99,99,99,99,99,99,99,99,99,99,99,100,100,100,100),
        array(60,83,95,104,109,113,115,116,117,118,119,119,119,119,119,119,119,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120)
        )
        BombCCRPWindow = 5
    }
    
    function vector bombCCIPWithGivenAltitude(Position:vector,Forward:vector,RangeTable:table,Altitude:number,Airspeed:number,DescentRate:number)
    {
        #get seconds to closing with ground, and move altitude up to compensate.  grav but some exp to reduce it
        local DropTime = Altitude / GRAVITY_IN_METERS_PER_SECOND
        local AdjustedAltitude = max(Altitude + (DescentRate * DropTime * 0.5),10)  #1-0.4, see "bomb speed getter" e2
        #get alt ratio, get speed ratio, look up and apply
        #altitude ratios.  10m increments, max of ???
        local AltitudeLookup = AdjustedAltitude / 10
        local LowerAltitudeIndex = int(AltitudeLookup)
        local UpperAltitudeIndex = LowerAltitudeIndex+1
        local AltitudeRatio = (AltitudeLookup - LowerAltitudeIndex) #/ 1#(UpperAltitudeIndex - LowerAltitudeIndex) #linear interpolation, just, some intwise fucky shit
        #airspeed ratios.  10m/s increments up to 50m/s
        local AirspeedLookup = min((Airspeed / 10)+1,6)
        local LowerAirspeedIndex = int(AirspeedLookup)
        local UpperAirspeedIndex = LowerAirspeedIndex+1
        local AirspeedRatio = (AirspeedLookup - LowerAirspeedIndex) #/ 1#(UpperAirspeedIndex - LowerAirspeedIndex) #linear interpolation, just, some intwise fucky shit
        
        #lookups, does linear interpolation between the 4 results based off weights from above
        local LowSlowLookup = RangeTable[LowerAirspeedIndex,array][LowerAltitudeIndex,number]
        local LowFastLookup = RangeTable[LowerAirspeedIndex,array][UpperAltitudeIndex,number]
        local HighSlowLookup = RangeTable[UpperAirspeedIndex,array][LowerAltitudeIndex,number]
        local HighFastLookup = RangeTable[UpperAirspeedIndex,array][UpperAltitudeIndex,number]
        #lower and upper lookups averaged
        local LowLookup = (LowSlowLookup * (1-AirspeedRatio)) + (LowFastLookup * AirspeedRatio)
        local HighLookup = (HighSlowLookup * (1-AirspeedRatio)) + (HighFastLookup * AirspeedRatio)
        local AveragedLookup = (LowLookup * (1-AirspeedRatio)) + (HighLookup * AirspeedRatio)
        #adjustment for if we're at max speed; less accurate, but acceptable.  It adjusts linearly off ratio of speed to offset, so 1.2x max speed = 1.2x drop drift at max speed.
        #This is how stock mpfc7 sights worked.  Bombing over 50m/s is generally inaccurate anyway, so this shouldn't be an issue
        if((AirspeedLookup == 6) & (AirspeedRatio == 1)) {AveragedLookup = (AveragedLookup / 50) * Airspeed}
        
        #this is translated into a world coord offset
        local ForwardDrift = Forward * AveragedLookup * 39.37
        local VerticalComponent = vec(0,0,AdjustedAltitude * -39.37)
        return Position + VerticalComponent + ForwardDrift
    }
    
    #[MISSILE BALLISTICS FUNCTIONS AND RANGE-TABLE BUILDING
    In case you were curious how i got these magic hacky numbers, and what they mean, they are the trajectory of a missile fired
    at level, in the angle of drop and the time of flight.  Because missiles have significant spread, I averaged it over multiple fires
    The info is local to the rack, but it should be efficient enough for acf combat.
    Added in mpfc 7.1 are also ballistics for guided missiles--this should help you get the most performance out of them by giving optimal launch angles :D]#
    local MISSILE_RANGE_TABLES = table()
    MISSILE_RANGE_TABLES["S24",array] = array(vec2(-3.5,0.4),vec2(-3.3,0.6),vec2(-3.1,0.8),vec2(-3,1),vec2(-3,1.1),vec2(-2.9,1.3),vec2(-2.8,1.4),vec2(-2.8,1.5),vec2(-2.8,1.7),vec2(-2.7,1.8),vec2(-2.7,1.9),vec2(-2.7,2.1),vec2(-2.7,2.2),vec2(-2.6,2.3),vec2(-2.6,2.5),vec2(-2.6,2.6),vec2(-2.7,2.8),vec2(-2.7,2.9),vec2(-2.8,3),vec2(-2.8,3.2),vec2(-2.9,3.3),vec2(-3,3.5),vec2(-3.1,3.7),vec2(-3.2,3.8),vec2(-3.3,4),vec2(-3.4,4.1),vec2(-3.5,4.3),vec2(-3.6,4.5),vec2(-3.7,4.7),vec2(-3.8,4.8),vec2(-3.9,5),vec2(-4,5.2),vec2(-4.1,5.4),vec2(-4.2,5.6),vec2(-4.3,5.8),vec2(-4.4,6),vec2(-4.5,6.2),vec2(-4.6,6.4),vec2(-4.7,6.6),vec2(-4.8,6.9),vec2(-4.9,7.1),vec2(-5,7.3),vec2(-5.1,7.6),vec2(-5.2,7.8),vec2(-5.3,8),vec2(-5.4,8.3),vec2(-5.5,8.5),vec2(-5.6,8.8))
    MISSILE_RANGE_TABLES["HVAR",array] = array(vec2(-1.8,0.3),vec2(-1.8,0.4),vec2(-1.7,0.5),vec2(-1.7,0.7),vec2(-1.7,0.8),vec2(-1.7,0.9),vec2(-1.7,1),vec2(-1.8,1.2),vec2(-1.9,1.3),vec2(-2,1.4),vec2(-2.2,1.6),vec2(-2.4,1.7),vec2(-2.6,1.9),vec2(-2.8,2),vec2(-3.1,2.2),vec2(-3.3,2.3),vec2(-3.6,2.5),vec2(-3.8,2.7),vec2(-4.1,2.9),vec2(-4.4,3.1),vec2(-4.7,3.3),vec2(-5.1,3.5),vec2(-5.4,3.7),vec2(-5.8,4),vec2(-6.2,4.2),vec2(-6.5,4.5),vec2(-7,4.7),vec2(-7.4,5),vec2(-7.9,5.3),vec2(-8.4,5.6),vec2(-8.9,5.9),vec2(-9.5,6.2),vec2(-10.1,6.5),vec2(-10.8,6.9),vec2(-11.5,7.2),vec2(-12.3,7.6),vec2(-13.1,8),vec2(-14,8.3),vec2(-14.9,8.7),vec2(-15.9,9.2),vec2(-16.9,9.6),vec2(-18,10),vec2(-19.1,10.5))
    MISSILE_RANGE_TABLES["RS82",array] = array(vec2(-2.4,0.4),vec2(-2.8,0.6),vec2(-3.2,0.7),vec2(-3.7,0.9),vec2(-4.2,1.1),vec2(-4.8,1.3),vec2(-5.5,1.5),vec2(-6.3,1.7),vec2(-7,1.9),vec2(-7.9,2.1),vec2(-8.7,2.4),vec2(-9.6,2.6),vec2(-10.6,2.9),vec2(-11.6,3.1),vec2(-12.7,3.4),vec2(-13.8,3.7),vec2(-15,4),vec2(-16.3,4.3),vec2(-17.6,4.6),vec2(-19.1,5),vec2(-20.5,5.4),vec2(-22.1,5.8),vec2(-23.8,6.2),vec2(-25.5,6.6),vec2(-27.4,7.1),vec2(-29.3,7.6),vec2(-31.4,8.1))
    MISSILE_RANGE_TABLES["ZUNI",array] = array(vec2(-1.6,0.3),vec2(-1.6,0.4),vec2(-1.6,0.5),vec2(-1.6,0.5),vec2(-1.6,0.6),vec2(-1.6,0.6),vec2(-1.7,0.7),vec2(-1.7,0.8),vec2(-1.8,0.8),vec2(-1.8,0.9),vec2(-1.9,0.9),vec2(-2,1),vec2(-2.1,1.1),vec2(-2.1,1.1),vec2(-2.2,1.2),vec2(-2.3,1.3),vec2(-2.3,1.3),vec2(-2.4,1.4),vec2(-2.5,1.5),vec2(-2.6,1.5),vec2(-2.7,1.6),vec2(-2.7,1.6),vec2(-2.8,1.7),vec2(-2.9,1.8),vec2(-3,1.8),vec2(-3.1,1.9),vec2(-3.1,2),vec2(-3.2,2),vec2(-3.3,2.1),vec2(-3.4,2.1),vec2(-3.5,2.2),vec2(-3.6,2.3),vec2(-3.6,2.3),vec2(-3.7,2.4),vec2(-3.8,2.5),vec2(-3.9,2.5),vec2(-4,2.6),vec2(-4.1,2.7),vec2(-4.2,2.7),vec2(-4.2,2.8),vec2(-4.3,2.9),vec2(-4.4,2.9),vec2(-4.5,3),vec2(-4.6,3.1),vec2(-4.7,3.1),vec2(-4.8,3.2),vec2(-4.8,3.3),vec2(-4.9,3.3))
    MISSILE_RANGE_TABLES["70MMFFAR",array] = array(vec2(-2,0.4),vec2(-2.1,0.5),vec2(-2.1,0.7),vec2(-2.2,0.9),vec2(-2.2,1),vec2(-2.3,1.2),vec2(-2.4,1.3),vec2(-2.5,1.5),vec2(-2.6,1.6),vec2(-2.7,1.8),vec2(-2.8,1.9),vec2(-3,2.1),vec2(-3.2,2.2),vec2(-3.4,2.4),vec2(-3.7,2.5),vec2(-4.1,2.7),vec2(-4.4,2.9),vec2(-4.8,3.1),vec2(-5.1,3.2),vec2(-5.5,3.4),vec2(-6,3.6),vec2(-6.5,3.8),vec2(-6.9,4),vec2(-7.5,4.2),vec2(-8,4.4),vec2(-8.5,4.6),vec2(-9.1,4.8),vec2(-9.7,5),vec2(-10.3,5.2),vec2(-10.9,5.4),vec2(-11.6,5.6),vec2(-12.3,5.9),vec2(-13,6.1),vec2(-13.7,6.3),vec2(-14.4,6.6),vec2(-15.2,6.8),vec2(-16,7.1),vec2(-16.8,7.4),vec2(-17.6,7.6),vec2(-18.4,7.9),vec2(-19.3,8.2),vec2(-20.2,8.5),vec2(-21.1,8.8))
    MISSILE_RANGE_TABLES["40MMFFAR",array] = array(vec2(-3.2,0.4),vec2(-3.3,0.6),vec2(-3.4,0.8),vec2(-3.5,1),vec2(-3.7,1.2),vec2(-3.9,1.4),vec2(-4.2,1.6),vec2(-4.6,1.8),vec2(-5.1,2),vec2(-5.6,2.2),vec2(-6.2,2.4),vec2(-6.8,2.6),vec2(-7.5,2.8),vec2(-8.2,3),vec2(-9,3.2),vec2(-9.7,3.5),vec2(-10.5,3.7),vec2(-11.4,3.9),vec2(-12.2,4.2),vec2(-13.1,4.4),vec2(-14,4.6),vec2(-15,4.9),vec2(-15.9,5.2),vec2(-16.9,5.4),vec2(-17.9,5.7),vec2(-18.9,6),vec2(-20,6.3),vec2(-21.1,6.6),vec2(-22.2,6.9),vec2(-23.3,7.2),vec2(-24.5,7.5),vec2(-25.7,7.8),vec2(-26.9,8.2),vec2(-28.1,8.5),vec2(-29.3,8.9),vec2(-30.6,9.3))
    MISSILE_RANGE_TABLES["ATAKA",array] = array(vec2(-0.8,0.3),vec2(-0.8,0.4),vec2(-0.9,0.6),vec2(-0.9,0.8),vec2(-0.9,1),vec2(-0.9,1.2),vec2(-0.9,1.3),vec2(-0.9,1.5),vec2(-0.9,1.7),vec2(-0.9,1.9),vec2(-0.9,2.1),vec2(-0.9,2.2),vec2(-0.9,2.4),vec2(-0.9,2.6),vec2(-0.9,2.8),vec2(-0.9,2.9),vec2(-0.9,3.1),vec2(-0.9,3.3),vec2(-0.9,3.5),vec2(-0.9,3.6),vec2(-0.9,3.8),vec2(-0.9,4),vec2(-0.9,4.2),vec2(-0.9,4.3),vec2(-0.9,4.5),vec2(-0.9,4.7),vec2(-0.9,4.9),vec2(-1,5.1),vec2(-1,5.2),vec2(-1,5.4),vec2(-1,5.6),vec2(-1,5.8),vec2(-1.1,6),vec2(-1.1,6.2),vec2(-1.2,6.4),vec2(-1.2,6.7),vec2(-1.3,6.9),vec2(-1.4,7.2),vec2(-1.4,7.5),vec2(-1.5,7.8),vec2(-1.6,8.2),vec2(-1.7,8.5),vec2(-1.8,8.9),vec2(-1.9,9.3),vec2(-2.1,9.7),vec2(-2.2,10.1),vec2(-2.4,10.6),vec2(-2.6,11),vec2(-2.8,11.5))
    MISSILE_RANGE_TABLES["AT3",array] = array(vec2(-4.6,0.7),vec2(-5,1.2),vec2(-5.9,1.7),vec2(-7.2,2.1),vec2(-8.6,2.6),vec2(-10.1,3),vec2(-11.6,3.5),vec2(-13.2,4),vec2(-14.8,4.5),vec2(-16.5,5),vec2(-18.2,5.5),vec2(-19.9,6.1),vec2(-21.6,6.6),vec2(-23.4,7.2),vec2(-25.2,7.8),vec2(-27.1,8.5),vec2(-29.2,9.2),vec2(-24.9,7.9))
    MISSILE_RANGE_TABLES["AGM114",array] = array(vec2(-1.5,0.3),vec2(-1.3,0.5),vec2(-1.2,0.7),vec2(-1.1,0.9),vec2(-1.1,1),vec2(-1.1,1.2),vec2(-1.1,1.4),vec2(-1.1,1.5),vec2(-1.1,1.7),vec2(-1.1,1.9),vec2(-1,2),vec2(-1,2.2),vec2(-1,2.4),vec2(-1,2.5),vec2(-1,2.7),vec2(-1,2.9),vec2(-1,3.1),vec2(-1,3.2),vec2(-1,3.4),vec2(-1,3.6),vec2(-1,3.8),vec2(-1,3.9),vec2(-1,4.1),vec2(-1.1,4.3),vec2(-1.1,4.4),vec2(-1.1,4.6),vec2(-1.1,4.8),vec2(-1.1,5.1),vec2(-1.1,5.3),vec2(-1.2,5.5),vec2(-1.2,5.8),vec2(-1.2,6.1),vec2(-1.3,6.3),vec2(-1.3,6.6),vec2(-1.3,7),vec2(-1.4,7.3),vec2(-1.4,7.7),vec2(-1.5,8.1),vec2(-1.5,8.5),vec2(-1.6,8.9),vec2(-1.6,9.4),vec2(-1.7,9.9),vec2(-1.8,10.4),vec2(-1.9,10.9),vec2(-2,11.5),vec2(-2.1,12.1),vec2(-2.2,12.7),vec2(-2.3,13.3),vec2(-2.5,14))
    MISSILE_RANGE_TABLES["AT2",array] = array(vec2(-6.8,0.7),vec2(-6.5,1.1),vec2(-6.6,1.3),vec2(-6.8,1.6),vec2(-7,1.9),vec2(-7.2,2.1),vec2(-7.3,2.3),vec2(-7.5,2.6),vec2(-7.7,2.8),vec2(-7.8,3),vec2(-8,3.2),vec2(-8.1,3.5),vec2(-8.3,3.7),vec2(-8.4,3.9),vec2(-8.5,4.1),vec2(-8.7,4.4),vec2(-8.8,4.6),vec2(-8.9,4.8),vec2(-9,5),vec2(-9.2,5.3),vec2(-9.3,5.5),vec2(-9.4,5.7),vec2(-9.5,5.9),vec2(-9.6,6.2),vec2(-9.7,6.4),vec2(-9.8,6.6),vec2(-9.9,6.8),vec2(-10,7.1),vec2(-10.2,7.3),vec2(-10.3,7.5),vec2(-7.7,5.2),vec2(-7.8,5.3),vec2(-7.9,5.6),vec2(-8,5.8),vec2(-8.1,6),vec2(-8.2,6.2),vec2(-8.3,6.5),vec2(-8.4,6.7),vec2(-8.5,6.9),vec2(-8.6,7.1),vec2(-8.7,7.3),vec2(-8.8,7.6),vec2(-2.8,3.4))
    MISSILE_RANGE_TABLES["AGM45",array] = array(vec2(-2.9,1.1),vec2(-2.4,1.5),vec2(-2.2,1.9),vec2(-2.1,2.2),vec2(-2.1,2.4),vec2(-2.1,2.7),vec2(-2,2.9),vec2(-2,3.1),vec2(-2,3.3),vec2(-2,3.5),vec2(-2,3.6),vec2(-2,3.8),vec2(-2,4),vec2(-2,4.1),vec2(-2,4.3),vec2(-2,4.4),vec2(-2,4.5),vec2(-2,4.7),vec2(-2,4.8),vec2(-2,4.9),vec2(-2,5),vec2(-2,5.2),vec2(-2,5.3),vec2(-2,5.4),vec2(-2,5.5),vec2(-2,5.6),vec2(-2,5.7),vec2(-2,5.8),vec2(-2,5.9),vec2(-1.9,6),vec2(-1.9,6.1),vec2(-1.9,6.2),vec2(-1.9,6.3),vec2(-1.9,6.4),vec2(-1.9,6.5),vec2(-1.9,6.6),vec2(-1.9,6.7),vec2(-1.9,6.8),vec2(-1.9,6.9),vec2(-1.9,7),vec2(-1.9,7.1),vec2(-1.9,7.2),vec2(-1.9,7.2),vec2(-1.9,7.3),vec2(-1.9,7.4),vec2(-1.9,7.5),vec2(-1.9,7.6),vec2(-1.9,7.7),vec2(-1.9,7.7))
    MISSILE_RANGE_TABLES["AGM122",array] = array(vec2(-5.1,0.6),vec2(-4.6,0.8),vec2(-4.2,1),vec2(-4,1.2),vec2(-3.8,1.3),vec2(-3.7,1.5),vec2(-3.6,1.6),vec2(-3.5,1.7),vec2(-3.5,1.8),vec2(-3.4,1.9),vec2(-3.4,2),vec2(-3.4,2.2),vec2(-3.4,2.3),vec2(-3.5,2.4),vec2(-3.5,2.5),vec2(-3.5,2.7),vec2(-3.6,2.8),vec2(-3.6,2.9),vec2(-3.7,3.1),vec2(-3.7,3.2),vec2(-3.8,3.3),vec2(-3.8,3.5),vec2(-3.9,3.6),vec2(-3.9,3.8),vec2(-4,3.9),vec2(-4.1,4.1),vec2(-4.2,4.3),vec2(-4.2,4.4),vec2(-4.3,4.6),vec2(-4.4,4.8),vec2(-4.5,4.9),vec2(-4.6,5.1),vec2(-4.7,5.3),vec2(-4.8,5.5),vec2(-4.8,5.7),vec2(-4.9,5.8),vec2(-5.1,6),vec2(-5.2,6.2),vec2(-5.3,6.4),vec2(-5.4,6.6),vec2(-5.5,6.8),vec2(-5.6,7),vec2(-5.8,7.3),vec2(-5.9,7.5),vec2(-6,7.7),vec2(-6.2,7.9),vec2(-6.3,8.1),vec2(-6.5,8.4),vec2(-6.6,8.6))
    MISSILE_RANGE_TABLES["BGM71",array] = array(vec2(-2.2,0.5),vec2(-2,0.8),vec2(-2,1.1),vec2(-2,1.5),vec2(-2.1,1.8),vec2(-2.2,2.1),vec2(-2.3,2.4),vec2(-2.4,2.7),vec2(-2.5,3.1),vec2(-2.6,3.4),vec2(-2.8,3.7),vec2(-2.9,4.1),vec2(-3.1,4.4),vec2(-3.3,4.7),vec2(-3.5,5),vec2(-3.8,5.4),vec2(-4.1,5.8),vec2(-4.5,6.2),vec2(-4.9,6.7),vec2(-5.5,7.2),vec2(-6.1,7.8),vec2(-7,8.3),vec2(-7.9,9),vec2(-9,9.6),vec2(-10.3,10.3),vec2(-11.8,10.9),vec2(-13.3,11.6),vec2(-15,12.3),vec2(-16.8,13.1),vec2(-18.6,13.8))
    
    local MISSILE_LOOKUP_TABLE = MISSILE_RANGE_TABLES:keys()
    local Missile1String = Missile_Type_1:replace("-",""):explode(" ")[1,string]
    local Missile2String = Missile_Type_2:replace("-",""):explode(" ")[1,string]
    foreach(K,V:string = MISSILE_LOOKUP_TABLE)
    {
        if(Missile1String == V) {Missile_1_Range_Table = MISSILE_RANGE_TABLES[V,array]}
        if(Missile2String == V) {Missile_2_Range_Table = MISSILE_RANGE_TABLES[V,array]}
    }
    #indexes if manually guided
    Missile_1_Guided = !Missile_1_Range_Table#:count()
    Missile_2_Guided = !Missile_2_Range_Table#:count()
    
    #integrates a set-altitude bomb function into an iterative cycle
    function vector bombCCIP(Position:vector,Forward:vector,RangeTable:table,Altitude:number,Airspeed:number,DescentRate:number)
    {
        local StepSize = 75   #75m steps
        local MaxIterations = 2   #over 150m, the difference of +/- regular terrain is minimal.  Use CCRP on uneven ground.  Or always.
        local StartPoint = Position
        local EndPoint = bombCCIPWithGivenAltitude(Position,Forward,RangeTable,min(StepSize,Altitude),Airspeed,DescentRate)
        local Iterations = 1
        #up to 200m, we should generally hit
        if(Altitude <= (StepSize * MaxIterations))
        {
            while(Iterations <= MaxIterations)
            {
                #trace len x 1.1 cuz shit likes to bug
                local Len = (StartPoint-EndPoint):length() * 1.1
                if(Iterations == MaxIterations) {Len = Len+Len}
                local Trace = rangerOffsetHull(Len,StartPoint,(EndPoint-StartPoint),vec(39.37))
                if(Trace:hit())
                {
                    #left world at
                    local TracePos = Trace:position()
                    local TraceAlt = (Position[3] - TracePos[3]) / 39.37
                    return bombCCIPWithGivenAltitude(Position,Forward,RangeTable,TraceAlt,Airspeed,DescentRate)
                }
                else
                {
                    StartPoint = Trace:position()
                    Iterations++
                    EndPoint = bombCCIPWithGivenAltitude(Position,Forward,RangeTable,Iterations*StepSize,Airspeed,DescentRate)
                }
            }
        }
        #either you were over 150m, or, you're aiming off a cliff.  either way, bad shit.  We fall back to default mode.
        return bombCCIPWithGivenAltitude(Position,Forward,RangeTable,Altitude,Airspeed,DescentRate)
        return EndPoint
    }
    
    #CANNON BALLISTICS
    #creates a ballistic range-table with drop and flighttime for bullets
    function array createGunRangeTable(Gun:entity)
    {
        #A reference holo
        holoCreate(450,vec(),vec(),ang())
        local ReferenceEntity = holoEntity(450)
        #Primary setups
        local Muzvel = Gun:acfMuzzleVel()
        local DragConstant = ( (3.1416 * (Gun:acfCaliber()/2)^2 )/10000)/(100*Gun:acfProjectileMass())
        local ACCEL = vec(0,0,-gravity())
        local Timescale = 0.099 #Timescale.  Perfect accuracy is at 0.066.  0.066*2 gives a still fairly good accuracy.  Drift will increase in proprtion to timescale accumulation errors.
        local Coordinates = array()
        #Initial flight setup
        local Flight = ReferenceEntity:forward():setZ(0) * (Muzvel * 39.37)
        local Pos = ReferenceEntity:pos()
        local Drag = vec()
        local NextPos = vec()
        #Used for range comparison, and drop adjustment
        local StartPos = Pos
        #Flags for data, will use for interpolation & storage later
        local TableIncrements = 20  #Range Increments
        local TableMaxRange = 800   #Maximum range
        local TableSlot = 1         #Slot it's attempting to insert data, start at 1
        #Stating value
        local Distance = 0
        #Backup to prevent failure on empty guns
        if(!Muzvel) {return Coordinates}
        #Actual ballistics table tabulation--accurate out to approximately 15 degrees drop deflection
        for(N=1,151)
        {
            Drag = Flight:normalized()*(DragConstant*Flight:length2())/Acf_Drag_Div
            NextPos = Pos + Flight*Timescale
            Flight = Flight + (ACCEL-Drag)*Timescale
            #Debug
            #holoCreate(N,NextPos)
            #Array building--if we pass a certain point, it flags the condition being met, averages the point & its predecessor, and stores it.
            Distance = ((NextPos - StartPos):setZ(0):length()) / 39.37 #This converts to meters, and, at the same time fixes the quite stupid gmod 1.33 map scaling thing.
            while(Distance > (TableIncrements*TableSlot))
            {
                Coordinates:pushVector2(vec2(ReferenceEntity:elevation((Pos + NextPos) / 2),N*Timescale))
                TableSlot++
            }
            if(Distance > TableMaxRange)
            {
                Coordinates:pushVector2(vec2(ReferenceEntity:elevation((Pos + NextPos) / 2),N*Timescale))
                TableSlot++
                holoDelete(450)
                return Coordinates
            }
            Pos = NextPos
        }
        #print(_HUD_PRINTCONSOLE,""+entity():getName()+": Failed to build total range table!\nTable compiled out to "+(Coordinates:count()*TableIncrements)+"m!",3)
        holoDelete(450) #Cleaning up our reference holo--I know it's a messy solution, it works though.
        return Coordinates
    }
        
    
    #HOLO INSTRUMENTS
    #creates instrument panel
    function void createHoloInstruments(Index:number,ReferenceEntity:entity,Is_Armed:number,Color:vector,DarkBacking:number,Scale:number,Position:vector)
    {
        local SkinMod = DarkBacking * 4
        local GaugeColor = ReferenceEntity:getColor()
        local BackingColor = (Color / 8)
        local Position = Position
        local PitchOffset = -15
        if(!Position)
        {
            Position = ReferenceEntity:pos()
            PitchOffset = 0
        }
                
        local Draw = 1
        #ifdef holoMaxAmount()
        Draw = 1#holoMaxAmount() > 60
        #endif
        #creating the gauge backings
        #center attitude indicator
        holoCreate(Index,Position,vec(Scale),ReferenceEntity:toWorld(ang(PitchOffset,180,0)))
        holoModel(Index,"models/sprops/trans/misc/gauge_1.mdl")
        holoSkin(Index,1+SkinMod)
        holoParent(Index,ReferenceEntity)
        local Master = holoEntity(Index)
        if(Draw)
        {
            #upper left--airspeed indicator
            holoCreate(Index+1,Master:toWorld(vec(0,-5.5,0) * Scale),vec(Scale),Master:toWorld(ang(0,0,180)))
            holoModel(Index+1,"models/sprops/trans/misc/gauge_1.mdl")
            holoSkin(Index+1,1+SkinMod)
            #upper right--altimeter
            holoCreate(Index+2,Master:toWorld(vec(0,5.5,0) * Scale),vec(Scale),Master:toWorld(ang(0,0,220)))
            holoModel(Index+2,"models/sprops/trans/misc/gauge_1.mdl")
            holoSkin(Index+2,2+SkinMod)
            #lower right--climb
            holoCreate(Index+3,Master:toWorld(vec(0,5.5,-5.5) * Scale),vec(Scale),Master:toWorld(ang(0,0,90)))
            holoModel(Index+3,"models/sprops/trans/misc/gauge_1.mdl")
            holoSkin(Index+3,3+SkinMod)
            #lower center--heading/radar warning
            holoCreate(Index+4,Master:toWorld(vec(0,0,-5.5) * Scale),vec(Scale),Master:angles())
            holoModel(Index+4,"models/sprops/trans/misc/gauge_1.mdl")
            holoSkin(Index+4,2+SkinMod)
            #lower left--gun ammo dial
            if(Is_Armed)
            {
                holoCreate(Index+5,Master:toWorld(vec(0,-5.5,-5.5) * Scale),vec(Scale),Master:angles())
                holoModel(Index+5,"models/sprops/trans/misc/gauge_1.mdl")
                holoSkin(Index+5,2+SkinMod)
            }
            #batch coloring and parenting
            for(N=0,4+Is_Armed)
            {
                holoParent(Index+N,Master)
                holoColor(Index+N,GaugeColor)
            }
            
            #creating overlays--needles glow and have a color
            #top left--airspeed indicator
            holoCreate(Index+6,Master:toWorld(vec(0,-5.5,0) * Scale),vec(0.35,0.35,0.1) * Scale,Master:toWorld(ang(90,0,0)))    #covering dial/master
            holoModel(Index+6,"hq_cylinder")
            holoColor(Index+6,BackingColor)
            holoParent(Index+6,Index)
            holoCreate(Index+7,holoEntity(Index+6):toWorld(vec(-1,0,0.6) * Scale),vec(0.02,0.01,0.18) * Scale,Master:toWorld(ang(0,90,0)))  #needle
            holoModel(Index+7,"prism")
            holoColor(Index+7,Color)
            holoParent(Index+7,Index+6)
            #top center--artificial horizon
            holoCreate(Index+8,Master:toWorld(vec() * Scale),vec(0.425) * Scale,ang())  #top/master ball
            holoModel(Index+8,"hq_icosphere")
            holoColor(Index+8,vec(0,255,0))
            holoClipEnabled(Index+8,1)
            holoClip(Index+8,vec(0,0,0),vec(0,0,1),0)
            holoParent(Index+8,Master)
            holoCreate(Index+9,Master:toWorld(vec() * Scale),vec(0.425) * Scale,ang())  #bottom/sub ball
            holoModel(Index+9,"hq_icosphere")
            holoColor(Index+9,vec(0,0,255))
            holoClipEnabled(Index+9,1)
            holoClip(Index+9,vec(0,0,0),vec(0,0,-1),0)
            holoParent(Index+9,Index+8)
            #upper right--altimeter
            holoCreate(Index+10,Master:toWorld(vec(0,5.5,0) * Scale),vec(0.35,0.35,0.1) * Scale,Master:toWorld(ang(90,0,0)))    #covering dial/master
            holoModel(Index+10,"hq_cylinder")
            holoColor(Index+10,BackingColor)
            holoParent(Index+10,Index)
            holoCreate(Index+11,holoEntity(Index+10):toWorld(vec(-1,0,0.6) * Scale),vec(0.02,0.01,0.18) * Scale,Master:toWorld(ang(0,90,0)))  #needle
            holoModel(Index+11,"prism")
            holoColor(Index+11,Color)
            holoParent(Index+11,Index+10)
            #lower right--vertical air speed
            holoCreate(Index+12,Master:toWorld(vec(0,5.5,-5.5) * Scale),vec(0.35,0.35,0.1) * Scale,Master:toWorld(ang(90,0,0)))    #covering dial/master
            holoModel(Index+12,"hq_cylinder")
            holoColor(Index+12,BackingColor)
            holoParent(Index+12,Index)
            holoCreate(Index+13,holoEntity(Index+12):toWorld(vec(0,-0.9,1) * Scale),vec(0.02,0.01,0.18) * Scale,Master:toWorld(ang(90,270,0)))  #needle
            holoModel(Index+13,"prism")    
            holoColor(Index+13,Color)
            holoParent(Index+13,Index+12)
            #lower center--heading indicator
            holoCreate(Index+14,Master:toWorld(vec(0,0,-5.5) * Scale),vec(0.45,0.45,0.1) * Scale,Master:toWorld(ang(90,0,0)))    #covering dial/master
            holoModel(Index+14,"hq_cylinder")
            holoColor(Index+14,BackingColor)
            holoParent(Index+14,Master)
            holoCreate(Index+15,holoEntity(Index+14):toWorld(vec(0,0,0.75) * Scale),vec(0.01,0.01,0.001) * Scale,holoEntity(Index+14):toWorld(ang(180,-90,0)))    #little jet indicator
            holoModel(Index+15,"models/xqm/jetbody3.mdl")
            holoMaterial(Index+15,"phoenix_storms/mat/mat_phx_metallic")
            holoColor(Index+15,Color)
            holoParent(Index+15,Index)
            holoCreate(Index+16,holoEntity(Index+14):toWorld(vec(-2.1,0,1) * Scale),vec(0.05) * Scale,Master:toWorld(ang(0,-90,0)))    #north indicator
            holoModel(Index+16,"models/sprops/misc/alphanum/alphanum_n.mdl")
            holoBodygroup(Index+16,0,2)
            holoMaterial(Index+16,"models/shiny")
            holoColor(Index+16,Color)
            holoParent(Index+16,Index+14)
            #toggle switch for lighting
            holoCreate(Index+17,Master:toWorld(vec(0.35,2.75,-2.75) * Scale),vec(0.7) * Scale,Master:toWorld(ang(90,0,0)))   #switch for lightign
            holoModel(Index+17,"models/bull/buttons/toggle_switch.mdl")
            #ifdef holoAnim(number,number)
                holoAnim(Index+17,1)
            #endif
            holoParent(Index+17,Master)
        }
        
        if(Is_Armed)
        {
            #lower left--ammunition indicator
            holoCreate(Index+18,Master:toWorld(vec(0,-5.5,-5.5) * Scale),vec(0.35,0.35,0.1) * Scale,Master:toWorld(ang(90,0,0)))    #covering dial/master
            holoModel(Index+18,"hq_cylinder")
            holoColor(Index+18,BackingColor)
            holoParent(Index+18,Index)
            holoCreate(Index+19,holoEntity(Index+18):toWorld(vec(-1,0,0.6) * Scale),vec(0.02,0.01,0.18) * Scale,Master:toWorld(ang(0,90,0)))  #needle
            holoModel(Index+19,"prism")
            holoColor(Index+19,Color)
            holoParent(Index+19,Index+18)
            #left center--little alphanum code
            holoCreate(Index+20,Master:toWorld(vec(0.45,-2.8,-2.8) * Scale),vec(0.1,0.01,0.1) * Scale,Master:toWorld(ang(0,-90,0)))   #alpha code for weapon state
            holoModel(Index+20,"models/sprops/misc/alphanum/alphanum_e.mdl")
            holoBodygroup(Index+20,0,3)
            holoMaterial(Index+20,"models/shiny")
            holoColor(Index+20,Color)
            holoDisableShading(Index+20,1)
            holoParent(Index+20,Master)
            #cover for it
            holoCreate(Index+21,Master:toWorld(vec(0.3,-2.8,-2.8) * Scale),vec(0.02,0.1,0.125) * Scale,Master:angles())   #alpha code for weapon state
            holoModel(Index+21,"models/holograms/hq_rcylinder.mdl")
            holoMaterial(Index+21,"models/shiny")
            holoColor(Index+21,vec4(0,0,0,96))
            holoParent(Index+21,Master)
        }
    }
    
    #matching function for updating those holo instruments
    function void updateHoloInstruments(Index:number,Speed:number,Angle:angle,Altitude:number,RateOfAscent:number,AmmoPercentage:number)
    {
        local RotationMaster = holoEntity(Index+17)
        #airspeed indicator, clamps at 90mph
        #Note: 0-30 is stall range yellow, 75 is warning speed, 85 is redline, 90 is max displayed
        holoAng(Index+6,RotationMaster:toWorld(ang(0,-2 + (clamp(Speed*2,0,180) * -1.75),0)))
        #artificial horizon
        holoAng(Index+8,RotationMaster:toWorld(Angle:setYaw(0) + ang(-90,180,0)))
        #altimeter, caps at 160m
        holoAng(Index+10,RotationMaster:toWorld(ang(0,2 + (clamp(Altitude,0,160) * -1.77),0)))
        #rate of ascent, caps at +/- 20
        holoAng(Index+12,RotationMaster:toWorld(ang(0,clamp(RateOfAscent,-20,20) * -7,0)))
        #heading
        holoAng(Index+14,RotationMaster:toWorld(ang(0,bearing(RotationMaster:pos(),-entity():forward():toAngle(),vec(0,9999999,0)) - 180,0)))
        #ammo percentage indicator
        holoAng(Index+18,RotationMaster:toWorld(ang(0,-220 - (AmmoPercentage*2.8),0)))
    }
    
    #illuminates said flight instruments, for bad weather flying
    function void illuminateInstruments(Index:number,Illuminate:number,Weapons:number)
    {
        #animating switch
        #ifdef holoAnim(number,number)
            holoAnim(Index+17,!Illuminate)
        #endif
        holoEntity(Index+17):soundPlay(500,0,"buttons/lightswitch2.wav")
        for(N=6,19)
        {
            if(N != 17) {holoDisableShading(Index+N,Illuminate)}
        }
    }
    
    #avionics telemetry
    function array updateAvionicsTelemetry(LastTelemetry:array)
    {
        #Speed, Angle, Altitude, Rate of Ascent, Curtime, Position
        #gathering related data
        local Position = entity():pos()
        local Curtime = curtime()
        local SpeedVector = (Position-LastTelemetry[6,vector]) / (Curtime - LastTelemetry[5,number])
        #direct data
        local Speed = SpeedVector:length() * 0.0425   #miles an hour
        local Angle = entity():angles()
        #altimeter
        local Altitude = 0
        if(entity():isUnderWater())
        {
            Altitude = 0.1
        }
        else
        {
            #temp flag set
            rangerHitEntities(0)
            local AltimeterLase = rangerOffset(32767,Position,vec(0,0,-1))
            local AltimeterPosition = AltimeterLase:position()
            rangerHitEntities(1)
            Altitude = (AltimeterPosition - Position):length() / 39.37  #meters
        }
        #rate of ascent
        local RateOfAscent = SpeedVector[3] * 0.0625 #ft/s
        return array(Speed,Angle,Altitude,RateOfAscent,Curtime,Position)
    }
    
    function void createHoloHud(Index:number,HoloCamParent:entity,Base:entity,ShootPos:vector,Position:vector,Color:vector)
    {
        local Pos = Position
        local Master = Base
        local Entity = entity()
        local PhysMaster = Master:isValid()
        if(PhysMaster)
        {
            Pos = Base:toWorld(vec(-0.5,0,3.4))
        }
        else
        {
            #holder for our glass
            holoCreate(Index,Position,vec(1),entity():toWorld(ang(150,0,0)))
            holoModel(Index,"models/props_wasteland/panel_leverhandle001a.mdl")
            holoParent(Index,entity())
            holoMaterial(Index,"sprops/textures/sprops_rubber")
            Master = holoEntity(Index)
            Pos = Master:toWorld(vec(-0.5,0,3.4))
            holoAlpha(Index,0)
        }
        #main backing glass
        holoCreate(Index+1,Pos,vec(0.05,0.6,0.85),Master:angles())
        holoMaterial(Index+1,"phoenix_storms/glass")
        holoParent(Index+1,Master)
        if(!PhysMaster) {holoAlpha(Index+1,128)}
        #center web sights
        #it will ATTEMPT to boresight them, but it can only do so within a small margin of error
        #therefore YOU have to set up your boresight to be accurate to a close enough amount, when building your cockpit!
        #[local Glass = holoEntity(Index+1)
        local PosOfGlass = Glass:pos()
        local Dist = (PosOfGlass - ShootPos):length() - 3
        local Localized = clamp(Glass:toLocal(ShootPos + (Entity:forward() * Dist)),vec(-3),vec(3))
        local TargetPos = Glass:toWorld(Localized)
        for(N=1,2)
        {
            holoCreate(Index+1+N,TargetPos,vec(0.05,0.5,0.5) * (0.5 + (N/2)),Master:angles())
            holoParent(Index+1+N,Master)
            holoModel(Index+1+N,"models/props_pipes/pipe01_connector01.mdl")
            holoMaterial(Index+1+N,"models/wireframe")
            holoColor(Index+1+N,vec4(Color,12))
            holoDisableShading(Index+1+N,1)
        }
        holoParent(Index+2,Master)
        holoParent(Index+3,Index+2)
        local WebSightCenter = holoEntity(Index+2):pos()]#
        local WebSightCenter = Pos
        #central pipper, what we move around for aiming
        holoCreate(Index+4,WebSightCenter,vec(0.015),Entity:angles())
        holoModel(Index+4,"hq_icosphere")
        holoParent(Index+4,HoloCamParent)
        #main light ring
        holoCreate(Index+5,WebSightCenter,vec(0.067),Entity:toWorld(ang(-90,0,0)))
        holoModel(Index+5,"hq_torus_thin")
        holoParent(Index+5,Index+4)
        #darker contrast ring ferf suggested
        holoCreate(Index+6,WebSightCenter,vec(0.067)*1.07,Entity:toWorld(ang(-90,0,0)))
        holoModel(Index+6,"hq_torus")
        holoParent(Index+6,Index+4)
        for(N=4,6)
        {
            if(N!=6) {holoColor(Index+N,vec4(Color,160))} else {holoColor(Index+N,vec4(Color*0.5,80))}
            holoDisableShading(Index+N,1)
            holoMaterial(Index+N,"models/shiny")
        }
        #Size of holo as 0.08, at a distance of 20, is equal to a 144x target at 100m
    }
    
    function number updateHoloHud(Index:number,Range:number,Target:vector,ShootPos:vector,ThirdPerson:number,LastReturn:number)
    {
        local DifferenceVector = (Target - ShootPos):normalized()
        local PosToSet = vec()
        local Dist = 39.37
        if(ThirdPerson)
        {
            PosToSet = ShootPos + (DifferenceVector * Dist)
        }
        else
        {
            Dist = abs(holoEntity(Index+4):toLocal(ShootPos)[1])
            local WebMaster = holoEntity(Index+1)
            local Local =  clamp(WebMaster:toLocal(ShootPos + (DifferenceVector * Dist)),vec(0,-2.5,-4),vec(0,2.5,4))
            PosToSet = WebMaster:toWorld(Local)
        }
        holoPos(Index+4,PosToSet)
        #rescales according to range
        local StradiaSize = clamp(((144 / 39.37) / Range) * (1.8 * (Dist/20)),0.02,0.2)
        holoScale(Index+5,vec(StradiaSize))
        holoScale(Index+6,vec(StradiaSize*1.07))
        #resets fixed holo if changed third person, we call manually via setting last return to -1
        #angles at 1/2 update rate
        if(LastReturn==4)
        {
            holoAng(Index+4,DifferenceVector:toAngle())
            return 0
        }
        return LastReturn+1
    }
    
    function void updateThirdPersonHoloHud(Index:number,ThirdPerson:number,Pilot:entity)
    {
        if(!ThirdPerson)
        {
            for(N=4,5) {holoVisible(Index+N,players(),1)}
        }
        else
        {
            local Players = getOtherPlayers(Pilot)
            for(N=4,5) {holoVisible(Index+N,Players,0)}
        }
    }
    
    #creates holographic flight controls
    function void createHoloFlightControls(Index:number,Seat:entity,Armed:number,Collective:number,ForwardThrottle:number,StickPosition:vector,CollectivePosition:vector,ThrottlePosition:vector)
    {
        #baik doesn't like to play nice
        local Draw = 1
        #ifdef holoMaxAmount()
        Draw = holoMaxAmount() > 60
        #endif
        if(Draw)
        {
            #default reversions
            local StickRootPosition = StickPosition
            if(!StickRootPosition) {StickRootPosition = Seat:toWorld(vec(0,10,5))}
            local CollectiveRootPosition = CollectivePosition
            if(!CollectiveRootPosition) {CollectiveRootPosition = Seat:toWorld(vec(-10.5,0,7))}
            local ThrottleRootPosition = ThrottlePosition
            if(!ThrottleRootPosition) {ThrottleRootPosition = Seat:toWorld(vec(-8,7,10))}
            #creates the primary stick
            #base
            holoCreate(Index,StickRootPosition,vec(0.4),ang())
            holoModel(Index,"hq_icosphere")
            holoMaterial(Index,"models/gibs/metalgibs/metal_gibs")
            holoParent(Index,Seat)
            #column
            holoCreate(Index+1,StickRootPosition + vec(0,1,7),vec(1),ang(180,0,0))
            holoModel(Index+1,"models/gibs/hgibs_spine.mdl")
            holoMaterial(Index+1,"models/combine_advisor/mask")
            holoParent(Index+1,Index)
            #top and button
            holoCreate(Index+2,StickRootPosition + vec(-2.25,1,12),vec(0.5),ang(0,90,90))
            holoModel(Index+2,"models/items/battery.mdl")
            holoMaterial(Index+2,"models/gibs/metalgibs/metal_gibs")
            holoParent(Index+2,Index)
            #armament trigger
            if(Armed)
            {
                holoCreate(Index+3,holoEntity(Index+2):toWorld(vec(-2.2,0,4.05)),vec(0.066),ang(0,0,90))
                holoModel(Index+3,"hq_cylinder")
                holoColor(Index+3,vec(255,0,0))
                holoMaterial(Index+3,"sprops/trans/lights/light_plastic")
                holoParent(Index+3,Index)
            }
            holoAng(Index,Seat:angles())  #setting start position of stick
            #creates pedals
            #left pedal
            holoCreate(Index+4,Seat:toWorld(vec(5,25,-12.75)),vec(0.4,0.8,0.1),Seat:angles())
            holoMaterial(Index+4,"Models/Weapons/V_Stunbaton/W_Shaft01a")
            holoModel(Index+4,"hq_rcube")
            holoParent(Index+4,Seat)
            #right pedal
            holoCreate(Index+5,Seat:toWorld(vec(-5,25,-12.75)),vec(0.4,0.8,0.1),Seat:toWorld(ang(0,0,180)))
            holoMaterial(Index+5,"Models/Weapons/V_Stunbaton/W_Shaft01a")
            holoModel(Index+5,"hq_rcube")
            holoParent(Index+5,Seat)
            #collective lever
            if(Collective)
            {
                holoCreate(Index+6,CollectiveRootPosition,vec(1),Seat:angles())
                holoModel(Index+6,"models/props_c17/TrapPropeller_Lever.mdl")
                holoMaterial(Index+6,"Models/props_trainstation/Trainstation_Arch001")
                holoParent(Index+6,Seat)
            }
            #throttle lever
            if(ForwardThrottle)
            {
                holoCreate(Index+7,ThrottleRootPosition,vec(0.7),Seat:toWorld(ang(0,90,0)))
                holoModel(Index+7,"models/props_wasteland/panel_leverhandle001a.mdl")
                holoMaterial(Index+7,"models/gibs/metalgibs/metal_gibs")
                holoClipEnabled(Index+7,1)
                #holoClip(number index,number clipidx,vector origin,vector normal,number isglobal)
                holoClip(Index+7,1,vec(),vec(0.5,3,1),0)
                holoParent(Index+7,Seat)
            }
        }
    }
    
    #updates holo flight controls
    #pedals go down and up, stick tilts, throttle and collective go foreback and updown
    function void updateHoloFlightControls(Index:number,LastReturn:number,Seat:entity,Fire:number,Collective:number,ForwardThrottle:number,CollectivePosition:vector,ThrottlePosition:vector,WS:number,AD:number,LR:number,UD:number,FB:number)
    {
        #baik doesn't like to play nice
        local Draw = 1
        #ifdef holoMaxAmount()
        Draw = holoMaxAmount() > 60
        #endif
        if(Draw)
        {
            #defaults and reversions
            local CollectiveRootPosition = CollectivePosition
            if(!CollectiveRootPosition) {CollectiveRootPosition = Seat:toWorld(vec(-10.5,0,7))}
            local ThrottleRootPosition = ThrottlePosition
            if(!ThrottleRootPosition) {ThrottleRootPosition = Seat:toWorld(vec(-8,7,10))}
            #stick
            holoAng(Index,Seat:toWorld(ang(AD,0,WS) * 15))
            #low priority
            if(LastReturn)
            {
                #left pedal
                holoPos(Index+4,Seat:toWorld(vec(5,25,-12.75 - LR)))
                holoPos(Index+5,Seat:toWorld(vec(-5,25,-12.75 + LR)))
                #fire
                holoPos(Index+3,holoEntity(Index+2):toWorld(vec(-2.2 + (Fire * 0.35),0,4.05)))
                #collective
                if(Collective) {holoPos(Index+6,CollectiveRootPosition + (Seat:up() * UD * 7))}
                #throttle
                if(ForwardThrottle) {holoPos(Index+7,ThrottleRootPosition + (Seat:forward() * FB * 5))}
            }
        }
    }
    
    #creates a predicted impact point, off a range table with 20m increments and formatted in a vec2 of "drop angle, time of flight in seconds"
    #note that addvelocitytyep is an enum/magic # for efficiency purposes.  0 is no addtitional velocity (leading target), 1 is a gun on stationary target, 2 is missile
    function vector createPIPOffRangeTable(Table:array,Range:number,Lead:angle,Weapon:entity,Pos:vector,Velocity:vector,AddVelocityType:number)
    {
        local DropModifier = cos(Weapon:angles()[1])
        local Drop = Table[round((Range * DropModifier) / 20),vector2][1]
        local FlightTime = Table[round(Range / 20),vector2][2]
        local SolutionAngle = (Lead * FlightTime) + ang(Drop,0,0)
        local AddVelocityMultiplier = 0
        #magic #s, fuck if i know why they work and ONLY HERE
        if(AddVelocityType == 2) {AddVelocityMultiplier = 0.5} elseif(AddVelocityType == 1) {AddVelocityMultiplier = 0.75}
        local VelocityCompensation = Velocity * FlightTime * AddVelocityMultiplier
        return Pos + ((Weapon:forward():toAngle() - SolutionAngle):forward() * Range * 39.37) + VelocityCompensation
    }
    
    #building ammo
    #cannons done by link
    foreach(K,V:entity = Cannon1:acfLinks())
    {
        Cannon_1_Starting_Ammo = Cannon_1_Starting_Ammo + V:acfCapacity()
        Cannon1Crates:pushEntity(V)
    }
    foreach(K,V:entity = Cannon2:acfLinks())
    {
        Cannon_2_Starting_Ammo = Cannon_2_Starting_Ammo + V:acfCapacity()
        Cannon2Crates:pushEntity(V)
    }
    foreach(K,V:entity = Cannon3:acfLinks())
    {
        Cannon_3_Starting_Ammo = Cannon_3_Starting_Ammo + V:acfCapacity()
        Cannon3Crates:pushEntity(V)
    }
    
    #missiles and bombs done by constraint tree search
    BOMB_CRATE_REFERENCE_TABLE = table()
    BOMB_CRATE_REFERENCE_TABLE["-1",string] = "NONE"
    BOMB_CRATE_REFERENCE_TABLE["50",string] = "50kgBOMB"
    BOMB_CRATE_REFERENCE_TABLE["70",string] = "70mmFFAR"
    BOMB_CRATE_REFERENCE_TABLE["100",string] = "100kgBOMB"
    BOMB_CRATE_REFERENCE_TABLE["250",string] = "250kgBOMB"
    BOMB_CRATE_REFERENCE_TABLE["500",string] = "500kgBOMB"
    BOMB_CRATE_REFERENCE_TABLE["1000",string] = "1000kgBOMB"
    BOMB_CRATE_REFERENCE_TABLE["62",string] = "WalleyeGBU"
    BOMB_CRATE_REFERENCE_TABLE["227",string] = "227kgGBU"
    BOMB_CRATE_REFERENCE_TABLE["454",string] = "454kgGBU"
    BOMB_CRATE_REFERENCE_TABLE["909",string] = "909kgGBU"
    
    MISSILE_CRATE_REFERENCE_TABLE = table()
    MISSILE_CRATE_REFERENCE_TABLE["S24",string] = "S-24 ASR"
    MISSILE_CRATE_REFERENCE_TABLE["HVAR",string] = "HVAR ASR"
    MISSILE_CRATE_REFERENCE_TABLE["RS82",string] = "RS82 ASR"
    MISSILE_CRATE_REFERENCE_TABLE["ZUNI",string] = "Zuni ASR"
    MISSILE_CRATE_REFERENCE_TABLE["70MMFFAR",string] = "70mmFFAR"
    MISSILE_CRATE_REFERENCE_TABLE["40MMFFAR",string] = "40mmFFAR"
    MISSILE_CRATE_REFERENCE_TABLE["ATAKA",string] = "Ataka ASM"
    MISSILE_CRATE_REFERENCE_TABLE["AT3",string] = "AT-3 ASM"
    MISSILE_CRATE_REFERENCE_TABLE["AGM114",string] = "AGM-114 ASM"
    MISSILE_CRATE_REFERENCE_TABLE["AT2",string] = "AT-2 ASM"
    MISSILE_CRATE_REFERENCE_TABLE["AGM45",string] = "AGM-45 ASM"
    MISSILE_CRATE_REFERENCE_TABLE["AGM122",string] = "AGM-122 ASM"
    MISSILE_CRATE_REFERENCE_TABLE["BGM71",string] = "BGM-71E ASM"
    MISSILE_CRATE_REFERENCE_TABLE["AIM120",string] = "AIM-120 AAM"
    MISSILE_CRATE_REFERENCE_TABLE["AIM9",string] = "AIM-9 AAM"
    MISSILE_CRATE_REFERENCE_TABLE["AIM54",string] = "AIM-54 AAM"
    MISSILE_CRATE_REFERENCE_TABLE["FIM92",string] = "FIM-92 SAM"
    

    local Type1 = MISSILE_CRATE_REFERENCE_TABLE[Missile_Type_1,string]
    local Type2 = MISSILE_CRATE_REFERENCE_TABLE[Missile_Type_2,string]
    local BombType = BOMB_CRATE_REFERENCE_TABLE[""+BombKg,string]
    foreach(K,V:entity = entity():getConstraints())
    {
        if(V:type() == "acf_ammo")
        {
            #is it a bomb
            local Type = V:acfRoundType()
            local TypeSplit1 = Type:explode("g")[2,string]
            #bombs
            if(Type == BombType)
            {
                BOMB_STARTING_AMMO += V:acfCapacity()
                BombCrates:pushEntity(V)
            }
            else
            {
                #rockets
                if(Type == Type1)
                {
                    Missile_1_Starting_Ammo += V:acfCapacity()
                    Missile_1_Crates:pushEntity(V)
                }
                if(Type == Type2)
                {
                    Missile_2_Starting_Ammo += V:acfCapacity()
                    Missile_2_Crates:pushEntity(V)
                }
            }
        }
    }
    
    #creating the instrument panel
    local Color = InstrumentPanelEntity:getColor()
    local PanelMaster = InstrumentPanelEntity
    local PanelPos = vec()
    if(!PanelMaster)
    {
        PanelMaster = entity()
        PanelPos = Seat:toWorld(vec(0,-2,36)) + (entity():forward() * 20) + (entity():up() * -4.25)
        Color = DEFAULT_HUDINSTRUMENT_COLOR
    }
    createHoloInstruments(160,PanelMaster,Is_Armed,Color,DarkBacking,InstrumentPanelScale,PanelPos)
    #creating the gunsight
    if(Is_Armed) {createHoloHud(182,holoEntity(0),HudEntity,Seat:toWorld(vec(0,-2,36)),Seat:toWorld(vec(0,-2,36)) + (entity():forward() * 20) + (entity():up()),Color)}
    #creating the flight controls
    createHoloFlightControls(191,Seat,Is_Armed,Flight_Model["cyclic or collective",number],Flight_Model["forward engine thrust",number],OptionalFlightStickPosition,OptionalCollectivePosition,OptionalThrottlePosition)
    
    #Pre-setting nav and ballistic computer to a "battlesight" range
    EngagementRange = 200
    #telling it finally to run at normal speed
    Tickrate = 75 #reduced from stock v7 to 75, all forces scaled to compensate
    Hash = hashNoComments()
}
#CONGRADULATIONS: MPFC IS NOW READY TO ACTUALLY DO SOMETHING!

#PRIMARY CONTROL LOOP
else
{    
    
    ##################
    #MAIN CODE BLOCK #
    ##################
    
    #INPUT OR CONTROL BASED EVENTS
    if(inputClk() | changed(State) | keyClk(Pilot))
    {
        #resets autolevel collective limiter, beeps to let you know it's ready
        if(changed(State))
        {
            if(State == "IDLE") {soundPlay(945,0,"buttons/bell1.wav")}
        }
        
        #Control Scheme Change
        if(!R | (R & (Pilot:keyPressed("mouse_4") | Pilot:keyPressed("mouse_5"))))
        {
            if((Input_PrevWeapon | Input_NextWeapon) | ((Pilot:keyPressed("mouse_4") | Pilot:keyPressed("mouse_5")) & R))
            {
                ZoomLevel = updateCamSettings(Cam,ThirdPerson & !CamThroughGunsight,Input_NextWeapon + Pilot:keyPressed("mouse_4"),Input_PrevWeapon + Pilot:keyPressed("mouse_5"))
            }
        }
        else
        {
            PrevWeapon = Input_PrevWeapon * 3
            NextWeapon = Input_NextWeapon * 3
        }
        
        if(changed(ExternalAutopilotCommand) & ExternalAutopilotCommand)
        {
            updateAutopilot(ExternalAutopilotCommand)
        }
    }
    
    #PILOT KEY CLICK EVENTS
    if(keyClk(Pilot) & Piloted)
    {
        #camoff we can use numpad too, because why not
        if(CamDisabled & !Seat:driver() & NumpadMode)
        {
            W = Pilot:keyPressed("pad_8")
            A = Pilot:keyPressed("pad_4")
            S = Pilot:keyPressed("pad_2")
            D = Pilot:keyPressed("pad_6")
            Space = Pilot:keyPressed("pad_enter")
            Shift = Pilot:keyPressed("pad_0")
            R = Pilot:keyPressed("pad_5")
            MouseUp = Pilot:keyPressed("pad_plus")
            MouseDown = Pilot:keyPressed("pad_minus")
        }
        else
        {
            W = Pod:number("W")
            A = Pod:number("A")
            S = Pod:number("S")
            D = Pod:number("D")
            R = Pod:number("R")
            Space = Pod:number("Space")
            Shift = Pod:number("Shift")
            Alt = Pod:number("Alt")
            Mouse1 = Pilot:keyAttack1()
            Mouse2 = Pilot:keyAttack2()
            MouseUp = Pilot:keyPressed("mouse_5") & !R
            MouseDown = Pilot:keyPressed("mouse_4") & !R
        }
        
        #key pressed that triggered
        local KeyClkPressed = keyClkPressed()
        #reload
        Reload = Pilot:keyAttack2() & R
        if(Reload & changed(Reload))
        {
            Cannon1:acfReload()
            Cannon2:acfReload()
            Cannon3:acfReload()
        }
        
        #camera off
        elseif((KeyClkPressed == "period") & Pilot:keyPressed("period"))
        {
            CamDisabled = !CamDisabled
            if(CamDisabled)
            {
                if(Pilot:keyReload())
                {
                    Seat:hintDriver("Cam disabled, press period to reenable.\nWASD is now 8462 numpad.\nSpace/shift is now enter/0 numpad.\nSide mouse buttons (throttle) can now be controlled with +/- numpad, 5 is R.",7)
                    NumpadMode = 1
                }
                else
                {
                    Seat:hintDriver("Cam disabled!",3)
                }
                State = "KEY"
                holoAlpha(44,0) #disabling gforce holo
            }
            else
            {
                NumpadMode = 0
                Seat:hintDriver("Cam enabled, press period to disable",3)
            }
            Cam["Activated",number] = !CamDisabled
        }
        
        if(!CamDisabled)
        {
            #1st/3rd person view
            if(Pilot:keyPressed("V"))
            {
                if(1)#if(State != "SIM")
                {
                    if(CamThroughGunsight)
                    {
                        CamThroughGunsight = !CamThroughGunsight
                    }
                    elseif(ThirdPerson)
                    {
                        if(R) {CamThroughGunsight = !CamThroughGunsight} else {ThirdPerson--}
                    }
                    else
                    {
                        if(R) {CamThroughGunsight = !CamThroughGunsight} else {ThirdPerson++}
                    }
                    
                    if(ThirdPerson & !CamThroughGunsight)
                    {
                        holoPos(0,Airframe_Bases[1,entity]:massCenter() + (entity():up() * Cam_Offset))
                    }
                    elseif(CamThroughGunsight)
                    {
                        if(SightHeadActive) {holoPos(0,SightHeadMaster:toWorld(SightHeadPos))} else {holoPos(0,Airframe_Bases[1,entity]:massCenter() + (entity():up() * Cam_Offset * -0.33) + (entity():forward() * Cam_Offset))}
                    }
                    else
                    {
                        holoPos(0,Seat:toWorld(vec(0,-2,36)) + (entity():forward() * 5))
                        CamThroughGunsight = 0
                    }
                    ZoomLevel = updateCamSettings(Cam,ThirdPerson & !CamThroughGunsight,0,0)
                    updateThirdPersonHoloHud(182,ThirdPerson,Pilot)
                    local HideShit = !CamThroughGunsight
                    if(!HideShit) {HideShit = -1}
                    updateHoloSightHead(45,SightHeadMaster,AimPoint,Position,Interval1200Timer,HideShit,Pilot)
                }
            }
            
            
            #Control scheme change
            if((KeyClkPressed == "lcontrol") & Pilot:keyPressed("lcontrol") & (State != "AUTO"))
            {
                #finite state machines
                #generic rcontrol
                if(!R & !Alt)
                {
                    if(State == "KEY") {State = "MOUSE"}
                    elseif(State == "MOUSE") {State = "KEY"}
                    elseif(State == "TERCOM") {State = "MOUSE"}
                    elseif(State == "JOY") {State = "KEY"}
                }
                #r+rcontrol, tercom
                elseif(R & !Alt)
                {
                    if((State == "KEY") | (State == "MOUSE")) {State = "TERCOM"}
                    elseif(State == "TERCOM") {State = "MOUSE"}
                    elseif(State == "JOY") {State = "TERCOM"}
                }
                #"raw", realistic flightsimmish control
                elseif(!R & Alt)
                {
                    if(State == "JOY") {State = "KEY"}
                    else {State = "JOY"}
                }
                Seat:hintDriver("Control mode: "+State+"",3)
            }
            
            #Autopilot quick binds
            elseif(!R & !CamDisabled)
            {
                if(Pilot:keyPressed(AP_RECORD_KEY))
                {
                    AP_Record = !AP_Record
                    if(AP_Record)
                    {
                        updateAutopilot("ap dir 0 "+AP_Waypoints:count())
                        Seat:hintDriver("Waypoint "+AP_Waypoints:count()+" set!",3)
                    }
                }
                else
                {
                    local KeyStringExplode = KeyClkPressed:explode("_")
                    local Valid = KeyStringExplode[1,string] == "pad"
                    if(Valid)
                    {
                        local Autopilot_Waypoint_Index = KeyStringExplode[2,string]:toNumber()
                        if(inrange(Autopilot_Waypoint_Index,1,9))
                        {
                            AP_Pushpoint = !AP_Pushpoint
                            if(AP_Pushpoint)
                            {
                                local Command = "cur 0 "+Autopilot_Waypoint_Index
                                updateAutopilot(Command)
                            }
                        }
                        else
                        {
                            AP_Pushpoint = 0
                        }
                    }
                }
            }
            #keypress transmit of radio coords
            else
            {
                #SCRL
                scr_keyTransmit(Seat,Cam["Trace",ranger]:position())
            }
            
            #FLIR
            Cam["FLIR",number] = Pilot:keyPressed("f") & !R
            
            #laser vs radar ranging
            local LaseInput = Pilot:keyPressed("i") | Pilot:keyPressed("mouse_middle")
            if(LaseInput)
            {
                Lase = !Lase
                if(Lase) {Seat:hintDriver("Air-To-Ground",5)} else {Seat:hintDriver("Air-To-Air",5)}
            }
            
            #Backlighting instrument panel
            if(Pilot:keyPressed("f") & R)
            {
                InstrumentsBacklit = !InstrumentsBacklit
                illuminateInstruments(160,InstrumentsBacklit,Is_Armed)
            }
            
            #Landing Gear Toggle
            if((KeyClkPressed == "l") & Pilot:keyPressed("l") & Gear_Model:length())
            {
                Gear_Down = !Gear_Down
                if(Gear_Down) {soundPlay(1,0,"acf_extra/airfx/gear_down.wav")} else {soundPlay(1,0,"acf_extra/airfx/gear_up.wav")}
                for(N=1,LandingGear:count())
                {
                    LandingGear[N,entity]:setAlpha(Gear_Down * 255)
                    #makes immune to damage because it's "retracted"
                    #ifdef entity:propNotSolid(number)
                    LandingGear[N,entity]:propNotSolid(!Gear_Down)
                    #endif

                    #parents and deparents to reduce lag, checks first we can also deparent before attempting
                    #we also deparent OVER TIME because the shit hurts physics
                    local CanDeparentToo = 0
                    local SetMass = 0
                    #ifdef entity:deparent()
                    CanDeparentToo++
                    #endif
                    #ifdef entity:parentTo(entity)
                    if(Gear_Down)
                    {
                        LandingGear[N,entity]:deparent()
                        LandingGearReinflationCycle = 5
                        soundPlay(999,0,"ambient/machines/steam_release_2.wav")
                    }
                    else
                    {
                        LandingGear[N,entity]:parentTo(entity())
                        SetMass++
                    }
                    #endif
                    if(SetMass)
                    {
                        #ifdef entity:setMass(number)
                        LandingGear[N,entity]:setMass(1.25)
                        #endif
                    }
                }
            }
            
            #Weaponry control
            if(Is_Armed)    #& !R)
            {
                local FireCircuit = Mouse1
                local WeaponSelectionCircuit = Mouse2 & !R
                WeaponSelected = WeaponSelected + WeaponSelectionCircuit
                
                #selecting, firing, and building ballistics for cannons
                if(BallisticComputerModeChar == "G")
                {
                    #if gun 1 selected, we link the fire circuit with the output for firing cannon 1
                    #if we're switching weapons, we make sure it's a valid weapon, create a range-table,
                    #and make other guns not fire.
                    if(WeaponSelected == 1)
                    {
                        FireCannon1 = FireCircuit & !WeaponSelectionCircuit
                        if(WeaponSelectionCircuit)
                        {
                            FireCannon2 = 0
                            FireCannon3 = 0
                            CannonRangeTable = createGunRangeTable(Cannon1)
                        }
                        CannonSelected = Cannon1
                    }
                    #weapon 2 we do the same with
                    elseif(WeaponSelected == 2)
                    {
                        FireCannon2 = FireCircuit & !WeaponSelectionCircuit
                        if(WeaponSelectionCircuit)
                        {
                            if(!Cannon2)
                            {
                                WeaponSelected = 1
                            }
                            else
                            {
                                FireCannon1 = 0
                                FireCannon3 = 0
                                CannonRangeTable = createGunRangeTable(Cannon2)
                            }
                        }
                        CannonSelected = Cannon2
                    }
                    #weapon 3 we do the same with
                    elseif(WeaponSelected == 3)
                    {
                        FireCannon3 = FireCircuit & !WeaponSelectionCircuit
                        if(WeaponSelectionCircuit)
                        {
                            if(!Cannon3)
                            {
                                WeaponSelected = 1
                            }
                            else
                            {
                                FireCannon1 = 0
                                FireCannon2 = 0
                                CannonRangeTable = createGunRangeTable(Cannon3)
                            }
                        }
                        CannonSelected = Cannon3
                    }
                    #we protect vs overflows
                    else
                    {
                        WeaponSelected = 1
                    }
                    #notifying us
                    if((changed(CannonSelected) & CannonSelected) | (changed(BallisticComputerModeChar)))
                    {
                        local String = ""+CannonSelected:acfNameShort():upper()+" selected"
                        if(CannonSelected:type() == "acf_gun")
                        {
                            if(CannonSelected:acfReady())
                            {
                                String = String + "\nREADY"
                            }
                            else
                            {
                                String = String + "\nNot Ready"
                            }
                        }
                        Seat:hintDriver(String,5)
                    }
                    #finally we tell it not to drop bombs or missiles, just in case we switched while firing
                    FireMissile1 = 0
                    FireMissile2 = 0
                    DropBombs = 0
                    #and update our ref ent for lead
                    LeadEntity = CannonSelected
                }
                
                #here we handle selection of missiles--a similar task, but simpler, because the outputs are there whether we have two missiles or one
                #We have no way of determining if we do or don't have a second missile, or even one missile.
                elseif(BallisticComputerModeChar == "M")
                {
                    if(WeaponSelected == 1)
                    {
                        FireMissile1 = FireCircuit & !WeaponSelectionCircuit
                        FireMissile2 = 0
                    }
                    elseif(WeaponSelected == 2)
                    {
                        FireMissile1 = 0
                        FireMissile2 = FireCircuit & !WeaponSelectionCircuit
                        if(!Missile_Type_2) {WeaponSelected = 1}
                    }
                    #protecting vs overflow
                    else
                    {
                        WeaponSelected = 1
                    }
                    #notifying pilot
                    if(changed(WeaponSelected) | changed(BallisticComputerModeChar))
                    {
                        if(WeaponSelected == 1) {Seat:hintDriver(""+Missile_Type_1:upper()+" selected",3)} elseif(WeaponSelected == 2) {Seat:hintDriver(""+Missile_Type_2:upper()+" selected",3)}
                    }
                    #finally we lock out other weapons
                    FireCannon1 = 0
                    FireCannon2 = 0
                    FireCannon3 = 0
                    DropBombs = 0
                    #and update lead reference ent
                    LeadEntity = entity()
                }
                
                #now, we handle bombs, which are way simpler
                #note we have a totally different section of code that handles the dropping.
                elseif(BallisticComputerModeChar == "B")
                {
                    #locking otu other weapons
                    FireCannon1 = 0
                    FireCannon2 = 0
                    FireCannon3 = 0
                    FireMissile1 = 0
                    FireMissile2 = 0
                    LeadEntity = entity()
                }
                
                #finally, unarmed, "safe" flight
                elseif(BallisticComputerModeChar == "N")
                {
                    FireCannon1 = 0
                    FireCannon2 = 0
                    FireCannon3 = 0
                    FireMissile1 = 0
                    FireMissile2 = 0
                    DropBombs = 0
                    LeadEntity = entity()
                }
                
                #select guns, bombs, or missiles
                if((KeyClkPressed == "g") | (KeyClkPressed == "c")) {BallisticComputerModeChar = "G"}      #CANNONS
                elseif(KeyClkPressed == "b") {BallisticComputerModeChar = "B"}  #BOMBS
                elseif(KeyClkPressed == "m") {BallisticComputerModeChar = "M"}  #MISSILES
                elseif(KeyClkPressed == "n") {BallisticComputerModeChar = "N"}  #NOT ARMED
                
                #gives our lovely bomb data computer the toggle for if it should override standard aim
                RemoteDatalinkWeaponsOverride = Pilot:keyPressed("rcontrol")
                if(changed(RemoteDatalinkWeaponsOverride) & RemoteDatalinkWeaponsOverride)
                {
                    if(RemoteDatalinkRequestPoint)
                    {
                        Seat:hintDriver("Bomb computer using uploaded data",3)
                        soundPlay(0,3,"ambient/computer_working.wav")
                    }
                    else
                    {
                        soundPlay(0,0,"buttons/combine_button_locked.wav")
                        RemoteDatalinkWeaponsOverride = 0
                    }
                }
                #update display
                holoModel(180,"models/sprops/misc/alphanum/alphanum_"+BallisticComputerModeChar+".mdl")
            }
            
            #aux outputs for like grabbers and doors and shit
            if(!R)
            {
                if((KeyClkPressed == "lbracket") & Pilot:keyPressed("lbracket")) {AuxOut1 = !AuxOut1}
                elseif((KeyClkPressed == "rbracket") & Pilot:keyPressed("rbracket")) {AuxOut2 = !AuxOut2}
            }
            else
            {
                if((KeyClkPressed == "lbracket") & Pilot:keyPressed("lbracket")) {AuxOut3 = !AuxOut3}
                elseif((KeyClkPressed == "rbracket") & Pilot:keyPressed("rbracket")) {AuxOut4 = !AuxOut4}
            }
        }
        
        #Engine ignition
        local IgnitionKey = "enter"
        if(CamDisabled) {IgnitionKey = "pad_multiply"}
        if(KeyClkPressed == IgnitionKey)
        {
            if(Pilot:keyPressed(IgnitionKey) & R)
            {
                Engines_On = !Engines_On
                #ifdef entity:propNotSolid(number)
                SightHeadMaster:propNotSolid(Engines_On)
                #endif
                if(Engines_On)   #engine on
                {
                    #flips physical switch holo; doesn't always work if you don't have it enabled.
                    #ifdef holoAnim(number,number)
                        holoAnim(176,0)   #160+16
                    #endif
                    FlightCPUAngle = entity():angles()
                    Seat:soundPlay(1,0,Sounds:string(1))
                    soundPlay(2,0,Sounds:string(2))
                    soundPlay(3,0,Sounds:string(3))
                    soundPitch(2,0)
                    soundPitch(3,0)
                    if(Flight_Model["wings",number]) {soundPlay(4,0,"acf_extra/vehiclefx/misc/windexternal.wav")}
                    soundVolume(4,0)
                    DamageSystemStart = curtime() + 5
                    #cog holo delete
                    holoDelete(500)
                    #set quat
                    Orientation = quat(entity())
                }
                else    #engine off
                {
                    reset()
                }
            }
        }
    }
    
    #PILOT CHAT EVENT
    elseif(chatClk(Seat:driver()))
    {
        #SCRL
        SCRLChatted = scr_chat(Seat,Cam["Trace",ranger]:position())
        if(!SCRLChatted)
        {
            local Pilot_LastSaid = Pilot:lastSaid():lower():explode(" ")
            
            #AUTOPILOT
            #Filtering if autopilot is to be used
            if(Pilot_LastSaid:string(1) == "ap")
            {
                #Inits
                hideChat(1)
                updateAutopilot(Pilot:lastSaid():lower())
            }
            
            #DETAIL PROP REMOVAL
            elseif(Pilot_LastSaid[1,string] == "lowlag")
            {
                hideChat(1)
                foreach(K,V:entity = entity():getConstraints())
                {
                    if((V:mass() <= 1) & V:type() == "prop_physics")
                        {
                            if(V != HudEntity)
                            {
                                #ifdef entity:propDelete()
                                V:propDelete()
                                #endif
                            }
                        }
                }
                soundPlay(199,0,"misc/outer_space_transition_01.wav")
            }
            
            #FREEZING SELF
            elseif(Pilot_LastSaid[1,string] == "fs")
            {
                hideChat(1)
                local Self = entity():getConstraints()
                Self:pushEntity(entity())
                local Freeze = Pilot_LastSaid[2,string]:toNumber()
                #ifdef entity:propFreeze(number)
                foreach(K,V:entity = Self) {V:propFreeze(Freeze)}
                #endif
                Self = array()
            }
            
            #DEBUG STAT OUTPUT
            elseif(Pilot_LastSaid[1,string] == "stat")
            {
                hideChat(1)
                printTable(Flight_Model)
            }
        }
    }
    
    #RADIO COMMUNICATIONS
    elseif(dsClk() & !SCRLChatted)
    {
        #SCRL
        if(!SCRLChatted)
        {
            local SCRLMessage = scr_recieve(Seat)
            #loads requests for arty support to the ballistic computer
            if(SCRLMessage[1,string] == "ARTY")
            {
                if(SCRLMessage[2,vector])
                {
                    RemoteDatalinkRequestPoint = SCRLMessage[2,vector]
                    Seat:hintDriver("Fire support data loaded!",4)
                }
            }
        }
    }
    
    #TERMINATION
    elseif(last())
    {
        for(N=1,LandingGear:count())
        {
            #ifdef entity:setMass(number)
            LandingGear[N,entity]:setMass(LandingGearWeights[N,number])
            #endif
            #ifdef entity:deparent()
            LandingGear[N,entity]:deparent()
            #endif
        }
    }
    
    #####################
    #PRIMARY CONTROL LOOP
    #####################
    
    elseif(!keyClk() | !chatClk())
    {
        #removing some magic
        SCRLChatted = 0
                
        #Ignition and startup branch
        Piloted = Pod:number("Active")
        if(changed(Piloted))
        {
            #IF A NEW PERSON SITS DOWN AS PILOT
            if(Piloted) #If someone gets in or out of hte pilots seat
            {
                Pilot = Seat:driver() #Getting the pilot
                holoPos(0,Seat:toWorld(vec(0,-2,36)) + (entity():forward() * 5))    #camera master
                holoVisible(44,Pilot,1) #gforce holo
                
                #Hints
                if(!Engines_On)
                {
                    Seat:soundPlay(99,0,Sounds:string(5))
                    Seat:hintDriver("Hold R and press ENTER to start this "+Flight_Model["name",string],7)
                }
                #Backcheck on legality and sight
                if(Is_Armed)
                {
                    if(Seat:model() != "models/vehicles/pilot_seat.mdl")
                    {
                        Seat:hintDriver("MPFC will not fly without using an acf pilot seat.",3)
                        NoCanFly = 1
                    }
                }
                
                #Cam active
                Cam["Activated",number] = 1
                #state update
                State = "KEY"
            }
            
            #PILOT GETS UP FROM SEAT
            else
            {
                Cam["Activated",number] = 0
                Cam["FOV",number] = 100
                if(!Engines_On) {State = "IDLE"}
                updateHoloSightHead(45,SightHeadMaster,AimPoint,Position,Interval1200Timer,-1,Pilot)
                holoVisible(44,Pilot,0) #gforce holo
                Pilot = entity()
            }
        }

            ###################
            #MAIN FLIGHT BRANCH
            ###################

            elseif(Engines_On & (clkName() == "interval")) #Engine must be on
            {
                #Extra holo bits
                #rotors do NOT like lower update rates
                if(HoloRotorsMode)
                {
                    #This is for things that have powered rotors--almost anything except autogyros
                    if(Flight_Model["collective",number])
                    {
                        rotateRotors(HoloRotorsMode,Index,RotorA,RotorB,StartSequence*1.5)
                    }
                    #This is for autogyros
                    else
                    {
                        Rotorrate = clamp(clamp((LocalVel[3] / 250) + (BaseVelLen / 1000),Rotorrate-0.03,Rotorrate+0.03),-1,1)
                        rotateRotors(HoloRotorsMode,Index,RotorA,RotorB,Rotorrate)
                    }
                }
                #propellors don't give a fuck
                if(Interval150Timer)
                {
                    if(Number_Of_Propellors)
                    {
                        for(N=1,Number_Of_Propellors)
                        {
                            rotatePropellor(60+(N*2),Propellor_Directions:number(N),StartSequence * 3)
                        }
                    }
                }
        
                #Here's our main flight stuff, all this huge segment.  Surprisingly buried, isn't it?
                #If you're down here, I salute you for your dedication.  A+.  All the gold stars.
                
                #Flight constants, indexing for future use.
                #TODO: what the fuck is with velocity vs local vel?
                Position = entity():pos()
                BaseVel = entity():vel()
                BaseVelLen = BaseVel:length()
                Velocity = entity():toLocal(Position + BaseVel) 
                LocalVel = entity():velL()
                Angle = entity():angles()
                Forward = entity():forward()
                
                #thread splitting.  Interval 150/300/600/1200 are synced with the main 75ms thread.
                CoreTimer++
                if(CoreTimer >= 16) {CoreTimer = 0}
                Interval150Timer = (CoreTimer%2) == 1
                #quarter rate timer
                Interval300Timer = (CoreTimer%4) == 1
                #1/8 rate timer
                Interval600Timer = (CoreTimer%8) == 1
                #1/16 rate timer
                Interval1200Timer = (CoreTimer%16) == 1
                
                if(Piloted & !CamDisabled)
                {
                    #Getting aimpoint and camera
                    #camera on
                    AimAng = Cam["CamAng",angle]
                    AimLoc = holoEntity(0):pos()
                    AimTrace = Cam["Trace",ranger]
                    AimForward = Cam["CamDir",vector]
                    AimPoint = AimTrace:position()
                    if(!LockAimpos) {Flypos = Cam["CamPos",vector] + (AimForward * FLYPOS_AIM_OFFSET_LEN)}
                }
                
                #keyboard/autolevel
                if(State == "KEY")
                {
                    #AUTOGYRO AND HELI
                    if(Flight_Model["collective",number] & Flight_Model["cyclic",number])
                    {
                        #ascent rate
                        local TiltAmnt = 10
                        local PositionZ = Position[3]
                        local AscentInput = clamp((Space-Shift)+(PrevWeapon-NextWeapon)+((MouseUp-MouseDown)/5),-1,1)
                        if(R) {AscentInput = clamp(AscentInput,-0.2,0.2)}
                        local AscentInputSmoothSpeed = 0.05
                        if(!AscentInput) {AscentInputSmoothSpeed = 1} #* (1 + (AscentInput == 0))
                        AutoLevelInputSmoothed = clamp(AscentInput,AutoLevelInputSmoothed-AscentInputSmoothSpeed,AutoLevelInputSmoothed+AscentInputSmoothSpeed)
                        #if(changed(State)) {LevelZ = PositionZ} else {LevelZ = LevelZ + (AscentRate * 39.37)}
                        local AscentRate = AutoLevelInputSmoothed * 29.52 #1m/s, assuming 75ms.  39.37 * 0.075 * 10 = 29.52
                        LevelZ += AscentRate
                        
                        #velocity compensation--we use thist o resist drifting
                        local VelocityCompensation = clamp(vec2(LocalVel),-393.7,393.7) / vec2(787.4,-787.4) 
                        #pitch
                        local CyclicPitchInput = CYCLIC_LIMIT
                        local RelaxedStickLimits = 360/StickLimits
                        if((W | S) & !(R | Alt)) {CyclicPitchInput = -(W - S * !R) * TiltAmnt * 2} else {CyclicPitchInput = VelocityCompensation[1] * (TiltAmnt)}
                        #roll
                        local CyclicRollInput = 0
                        if((A | D) & (R | Alt)) {CyclicRollInput = (A - D) * TiltAmnt * 2} else {CyclicRollInput = VelocityCompensation[2] * (TiltAmnt)}
                        
                        #pid control used for ascent, tilt is done by simple feedback
                        #PID is velocity & coordinate comparision if we're hovering. if we're descending or ascending, it just tries to max up/down by feeding it impossible parameters of speed
                        if((int(AutoLevelInputSmoothed) != AutoLevelInputSmoothed) | !AutoLevelInputSmoothed) #if not +/-1 or 0
                        {
                            Input_UD = autoHoverUD(LevelZ,Position[3],AscentRate)
                        }
                        else
                        {
                            Input_UD = AutoLevelInputSmoothed
                            LevelZ = Position[3]
                        }
                        Input_WS = clamp((Angle[1]+CyclicPitchInput) / RelaxedStickLimits,-1,1)
                        local RollAng = (abs(Angle[3]) > (StickLimits / 2)) ? (Angle[3]) : (Angle[3] * 0.5)
                        Input_AD = -clamp((RollAng+CyclicRollInput) / RelaxedStickLimits / 5,-1,1)
                        if(R) {Input_LR = clamp(entity():bearing(AimPoint) / StickLimits / 2,-1,1)} else {Input_LR = (D-A) * !Alt}
                        Input_FB = (W-S) * (R | Alt)
                    }
                    #AIRPLANE
                    else
                    {
                        #aim override for bombardier
                        local BombingRunAim = AimPoint
                        if(AutomatedBombAimpos & RemoteDatalinkWeaponsOverride) {BombingRunAim = AutomatedBombAimpos}
                        
                        #our deflection offsets
                        #WASD is flight direction, pgup/down is throttle, space/shift is flaps
                        #R+Mouse is for level bombing w/ WS taking over throttle, R+A/D is pylon turn
                        local ElevationInput = (W-S) * !R
                        local BearingInput = (D-A) * !R
                        if(R) {BearingInput = clamp(entity():bearing(BombingRunAim) / StickLimits,-1,1)}
                        #pylon turn input
                        local PylonInput = (A-D) * R
                        if(PylonInput) {BearingInput = 0}
                        #thrust input
                        local ThrustInput = clamp((Pilot:keyPressed("pageup") - (Pilot:keyPressed("pagedown"))) + ((W-S) * R),-1,1)
                        #flaps input
                        local FlapsInput = Space-Shift
                        #coordinate adjustment 
                        local ForwardOffsetLength = BaseVelLen
                        local LevelZLimiter = ForwardOffsetLength / StickLimits
                        #altitude holding
                        if(ElevationInput)
                        {
                            LevelZ = Position[3]
                        }
                        else
                        {
                            local PositionZ = Position[3]  #precaching
                            LevelZ = clamp(LevelZ,PositionZ - LevelZLimiter,PositionZ + LevelZLimiter)  #worst case scenario fix.
                        }
                        
                        #pylon specific
                        local RollPointingToPoint = elevation(Position,Angle:setRoll(0),AimPoint) * PylonInput
                        #standard forward flight
                        if(!PylonInput)
                        {
                            local FixedAngle = Forward:setZ(0):toAngle()
                            Flypos = Position:setZ(LevelZ) + (((FixedAngle:forward():setZ(0)) + (FixedAngle:right():setZ(0) * BearingInput) + (FixedAngle:up() * ElevationInput)) * ForwardOffsetLength)
                        }
                        
                        else
                        {
                            local ZMod = (LevelZ * 0.05) + (Position[3] * 0.95) - (Velocity[3] * 0.1)
                            Flypos = (Position + (AimAng:right() * (BaseVelLen * 0.5) * PylonInput)):setZ(ZMod) #pylon turn
                        }
                        #flight heading, similar to cam-mouse mode
                        local FlightHeading = getHeadingAutoroll(Flypos,StickLimits,FlightCPUAngle,Flight_Model["self leveling",number],Flight_Model["cyclic ratio",number],Position,Flight_Model,(A&D) | R)
                        Input_WS = FlightHeading[1]  #pitch up at point
                        if(!PylonInput) 
                        {
                            Input_AD = clamp((-FlightCPUAngle[3] + (FlightHeading[3]) * max((Flight_Model["maneuverability",angle][3] / Flight_Model["maneuverability",angle][2]) * 30,90)),-StickLimits,StickLimits) / StickLimits
                        }
                        else
                        {
                            Input_AD = -(FlightCPUAngle[3] - RollPointingToPoint) / (StickLimits / 2)#45 #90
                        }
                        Input_LR = FlightHeading[2] * (1 + (abs(PylonInput) * 3))    #our rudder is more sensitive during a pylon turn, because it'll already inherently spiral slightly
                        Input_UD = FlapsInput
                        Input_FB = ThrustInput
                    }
                    
                    #adding side mouse buttons and R+mousewheel
                    if(Flight_Model["collective",number])
                    {
                        Input_UD = clamp(Input_UD - NextWeapon + PrevWeapon,-1,1)
                    }
                    else
                    {
                        Input_FB = clamp(Input_FB - NextWeapon + PrevWeapon + MouseUp - MouseDown,-1,1)
                    }
                }
                
                #mouse
                elseif(State == "MOUSE")
                {
                    local FlightHeading = getHeadingAutoroll(Flypos,StickLimits,FlightCPUAngle,Flight_Model["self leveling",number],Flight_Model["cyclic ratio",number],Position,Flight_Model,A&D)
                    local OverrideInput_AD = D-A
                    if(R)
                    {
                        Input_AD = 0
                    }
                    elseif(!OverrideInput_AD) #autoroll
                    {
                        #for some reason this works.  At anything higher input_ad will oscillate on hard turns
                        Input_AD = clamp((-FlightCPUAngle[3] + (FlightHeading[3]) * max((Flight_Model["maneuverability",angle][3] / Flight_Model["maneuverability",angle][2]) * CYCLIC_LIMIT,90)),-StickLimits,StickLimits) / StickLimits

                    }
                    else
                    {
                        #planes, compound helis, etc
                        if(Flight_Model["forward engine thrust",number])
                        {
                            Input_AD = OverrideInput_AD - ((FlightCPUAngle[3]/CYCLIC_LIMIT) * Flight_Model["self leveling",number] * (1 - FB))
                        }
                        #helis
                        else
                        {
                            Input_AD = OverrideInput_AD - ((FlightCPUAngle[3]/CYCLIC_LIMIT) * Flight_Model["self leveling",number])
                        }
                        
                    }
                    
                    if(BombingPullupInput) {Input_WS = BombingPullupInput} else {Input_WS = FlightHeading[1]}
                    #Input_WS = FlightHeading[1]
                    Input_LR = FlightHeading[2]
                    Input_UD = clamp((Space - Shift) * !R,-1,1)
                    Input_FB = clamp((W - S) * !R,-1,1)
                    #adding side mouse buttons and R+mousewheel
                    if(Flight_Model["collective",number])
                    {
                        Input_UD = clamp(Input_UD - NextWeapon + PrevWeapon + MouseUp - MouseDown,-1,1)
                    }
                    else
                    {
                        Input_FB = clamp(Input_FB - NextWeapon + PrevWeapon + MouseUp - MouseDown,-1,1)
                    }
                }
                
                #ground-hugging
                elseif(State == "TERCOM")
                {
                    
                    #variable for alt
                    local PilotInputWS = (W - S) * !R
                    #get altitude, and target altitude
                    local TercomAltitude = AvionicsData[3,number]
                    #difference
                    local TercomAltitudeRatio = (TERCOM_TARGET_ALTITUDE-TercomAltitude) / TERCOM_TARGET_ALTITUDE
                    
                    #first an emergency-pullup trace is done if ap lane, else it traces terrain ahead if this doesn't hit or isn't necessary
                    local ForeStep = TERCOM_TIMESTEP * TERCOM_FRONT_OFFSET
                    local TercomForwardTrace = rangerOffset(BaseVelLen * TERCOM_TIMESTEP * 0.25,Position + (Forward * TERCOM_FRONT_OFFSET) + (entity():up() * TERCOM_TARGET_ALTITUDE * -0.5),Forward)  #1-second of flight emergency trace
                    #plane emergency pullup
                    if(TercomForwardTrace:hit() & Flight_Model["forward engine thrust",number])
                    {
                        Flypos = AimPoint:setZ(Position[3] + TERCOM_TARGET_ALTITUDE * 393.7)
                    }
                    else
                    {
                        local TercomAltMod = (TERCOM_TARGET_ALTITUDE * 39.37) - (BaseVel[3] * TERCOM_DAMPENING) + (TercomAltitudeRatio * TERCOM_ALTIMETER_EFFECT * 39.37)
                        if(Flight_Model["forward engine thrust",number])
                        {
                            local ForwardOffset = Position + (Forward * (TERCOM_TRACE_SIZE_VEC + ForeStep))
                            TercomTrace = rangerOffsetHull(65535,ForwardOffset,Forward:setZ(-TERCOM_DOWNWARD_RATIO),TERCOM_TRACE_SIZE_VEC) #BaseVelLen * TERCOM_TIMESTEP
                            Flypos = AimPoint:setZ(TercomTrace:position()[3] + (TERCOM_TARGET_ALTITUDE * 39.37))
                        }
                        else
                        {
                            local VelRatio = clamp(BaseVelLen / 1000,0,0.5)
                            local ForwardOffset = Position + (Forward  * (TERCOM_TRACE_SIZE_VEC + ForeStep))
                            TercomTrace = rangerOffsetHull(max(BaseVelLen,393.7) * TERCOM_TIMESTEP,ForwardOffset,AimForward * vec(1,1,(1-VelRatio)),TERCOM_TRACE_SIZE_VEC)
                            Flypos = AimPoint
                        }
                    }
                    #gets flight heading, acts similar to regular mouse flight.  Helis get magical pitch
                    local FlightHeading = getHeadingAutoroll(Flypos,StickLimits,FlightCPUAngle,Flight_Model["self leveling",number],Flight_Model["cyclic ratio",number],Position,Flight_Model,0)
                    #roll
                    Input_AD = clamp((-FlightCPUAngle[3] + (FlightHeading[3]) * max((Flight_Model["maneuverability",angle][3] / Flight_Model["maneuverability",angle][2]) * 30,90)),-StickLimits,StickLimits) / StickLimits
                    
                    #pitch
                    if(Flight_Model["cyclic",number])
                    {
                        #pitch dampening
                        local PitchDampening = (LocalVel[1] / 500) * CYCLIC_LIMIT * !PilotInputWS
                        local TiltRatio = clamp(TercomAltitudeRatio * -0.1,0.25,0.5)
                        local TargetPitchInput = -(PilotInputWS * CYCLIC_LIMIT * TiltRatio)
                        #if we are gonna crash, we stop entirely
                        Input_WS = clamp((Angle[1] + TargetPitchInput + PitchDampening) / StickLimits / 5,-1,1)
                    }
                    else
                    {
                        Input_WS = FlightHeading[1] * 2    #extremely sensitive to pitch
                    }
                    
                    #collective/flaps/thrust
                    if(Flight_Model["collective",number])
                    {
                        #gets target altitude
                        #balances tercom trace, altimeter reading, and velocity state to determine optimal altitude; will discard tercom if tercom not appropriate
                        local TargetAltMod = 1 + (BaseVelLen / 500)
                        local TercomPos = TercomTrace:position()
                        local AltimeterLevelZ = Position[3] - (TercomAltitude * 39.37)
                        local TercomLevelZ = TercomPos[3]
                        local AltimeterTercomWeightingRatio = (0.25 + (abs(PilotInputWS) * 0.5))
                        local TargetLevelZ = max((AltimeterLevelZ * (1-AltimeterTercomWeightingRatio)) + (TercomLevelZ * AltimeterTercomWeightingRatio),AltimeterLevelZ)
                        LevelZ = (TargetLevelZ + (TERCOM_TARGET_ALTITUDE * 39.37 * TargetAltMod))
                        #target altitude fed into flight computer
                        Input_UD = autoHoverUD(LevelZ,Position[3],$LevelZ)
                    }
                    else
                    {
                        Input_UD = 1
                    }
                    if(Flight_Model["forward engine thrust",number])
                    {
                        if(!PilotInputWS)
                        {
                            local StallTarget = Flight_Model["stall",number] * 1.25 + (PilotInputWS * 9999)
                            Input_FB = ((StallTarget - Velocity:length()) / (StallTarget / 10)) * (2-cos(Angle[1]))
                        }
                        else
                        {
                            Input_FB = PilotInputWS
                        }
                    }
                    Input_LR = FlightHeading[2]
                }
                
                #autopilot
                elseif(State == "AUTO")
                {
                    #preresetting controls and locals
                    Input_WS = 0
                    Input_AD = 0
                    Input_LR = 0
                    Input_UD = 0
                    Input_FB = 0
                    
                    #GETTING CURRENT OPCODE
                    local AP_OPCode = AP_OPCodes[AP_CurrentIndex,string]
                    
                    #JMP to a new index and reevaluate operation code; intentionally set up to fail if it's a double-jump.
                    if(AP_OPCode == "JMP")
                    {
                        #if the current index is a jump command, it'll reset pointer to that
                        AP_CurrentIndex = AP_Waypoints[AP_CurrentIndex,number]
                        AP_OPCode = AP_OPCodes[AP_CurrentIndex,string]
                    }
                    
                    #Fly to a coordinate
                    if(AP_OPCode == "PNT")
                    {
                        AP_Flypos = AP_Waypoints[AP_CurrentIndex,vector]
                        #if we are within 1s of coordinate, our "pointer" jumps to the next "address"
                        if((AP_Flypos-Position):length() < BaseVelLen)
                        {
                            AP_CurrentIndex++
                        }
                        #if not, we keep flying at our waypoint
                        else
                        {
                            #now that we have coordinates and all sorted out, we get flight heading and cyclic and such
                            local FlightHeading = getHeadingAutoroll(AP_Flypos,StickLimits,FlightCPUAngle,Flight_Model["self leveling",number],Flight_Model["cyclic ratio",number],Position,Flight_Model,0)
                            local AltDifference = (AP_Flypos-Position)[3]
                            #TODO: make this cleaner, maybe refactor into getHeadingAutoroll?  Ugly.
                            if(!Flight_Model["cyclic",number])
                            {
                                Input_WS = FlightHeading[1]
                                Input_UD = (AltDifference / 250) - UD
                                Input_AD = clamp((-FlightCPUAngle[3] + (FlightHeading[3]) * max((Flight_Model["maneuverability",angle][3] / Flight_Model["maneuverability",angle][2]) * CYCLIC_LIMIT,90)),-StickLimits,StickLimits) / StickLimits
                            }
                            else
                            {
                                if(inrange(entity():bearing(AP_Flypos),-StickLimits/2,StickLimits/2))
                                {
                                    local DesiredPitch = 10 - (clamp((AP_Flypos-Position)[3] / 500,-20,10))
                                    Input_WS = clamp((Angle[1] - DesiredPitch) / StickLimits,-1,1)
                                }
                                else
                                {
                                    Input_WS = clamp((Angle[1]) / StickLimits,-1,1)
                                }
                                Input_UD = ((AltDifference - (LocalVel[3])) / 100) - UD + Hover_UD_Est
                                Input_AD = clamp((-FlightCPUAngle[3] * max((Flight_Model["maneuverability",angle][3] / Flight_Model["maneuverability",angle][2]) * CYCLIC_LIMIT,90)),-StickLimits,StickLimits) / StickLimits
                            }
                            #processes all our state information back into an input model.
                            Input_LR = FlightHeading[2]
                            Input_FB = Pod:number("W") - Pod:number("S")
                        }
                    }
                    
                    #End of our command list
                    if(!AP_OPCode | AP_OPCode == "OFF")
                    {
                        Seat:hintDriver("Autopilot off!",3)
                        State = "KEY"
                        AP_CurrentIndex = 1
                    }
                }
                
                #joystick
                elseif(State == "JOY")
                {
                    JoyWS = Joystick["1",number] / 10
                    JoyAD = Joystick["2",number] / 10
                    JoyLR = Joystick["3",number] / 10
                    JoyUD = Joystick["4",number] / 10
                    JoyFB = Joystick["5",number] / 10
                    
                    Input_WS = $JoyWS
                    Input_AD = $JoyAD
                    Input_LR = $JoyLR
                    Input_UD = $JoyUD
                    Input_FB = $JoyFB
                }
                
                #Force input code finalization, includes anti-oscillation dampening
                WS = clamp(Input_WS,-1,1)
                AD = clamp(Input_AD,-1,1)
                LR = clamp(Input_LR,-1,1)
                UD = getAccumulatedValue(UD,Input_UD,(0.05 + (AutoLevelCollectiveBoost * 0.95)) * Flight_Model["collective responsiveness",number],(Shift * -0.25) * Flight_Model["collective",number],1)
                FB = getAccumulatedValue(FB,Input_FB,(0.05 * Flight_Model["thrust responsiveness",number]),(-0.25 * (Input_FB == -1)),1)
                
                #low-priority controls
                if(Interval150Timer)
                {
                    #updates our camera head if we have one
                    if(SightHeadActive) {updateHoloSightHead(45,SightHeadMaster,AimPoint,Position,Interval1200Timer,0,Pilot)}
                    
                    local AmmoRatio = 0
                    #ballistics
                    if(Is_Armed & Piloted & !CamDisabled)
                    {
                        #lead
                        if(!Lase)
                        {
                            #gets angular deflection rate off a ref entity, 0.075 is $curtime
                            local LeadEntityForward = LeadEntity:forward()
                            local NewLeadReferenceAngle = LeadEntityForward:toAngle()
                            local LeadEntityPos = LeadEntity:pos()
                            local LeadHeading = heading(LeadEntityPos,LeadReferenceAngle,LeadEntityPos + (LeadEntityForward * 65535)) * -(1/0.075)
                            LeadReferenceAngle = NewLeadReferenceAngle
                            #smoothing
                            Lead = (Lead * 0.7) + (LeadHeading * 0.3)
                        }
                        else
                        {
                            if(Interval300Timer) {LeadReferenceAngle = LeadEntity:forward():toAngle()}
                            Lead = ang()
                        }
                        
                        #ranging
                        if(Interval300Timer)
                        {
                            #"radar" ranging.  It throws a huge hull trace and returns range
                            if(!Lase)
                            {
                                local RangerFlags = rangerFlags()
                                local RadarCycle = 0
                                local RadarDirection = (BallisticSolution - Position):normalized()#AimForward#
                                SightLockStatus = 0
                                while(!SightLockStatus & (RadarCycle < 2))
                                {
                                    local RadarOffset = (50 + (RadarCycle * 175)) * 39.37  #short is 50m, long is 225m
                                    local RadarSize = (25 * (1+RadarCycle)) * 39.37   #short is 25m, long is 50m
                                    local RadarDist = 175 * 39.37 #175m increments.  50m offset + 175m = 225, then 400
                                    RangingTrace = rangerOffsetHull(RadarDist,Position + (RadarDirection * RadarOffset),RadarDirection,vec(RadarSize))
                                    #[holoCreate(990+RadarCycle,RangingTrace:position(),vec())
                                    holoScaleUnits(990+RadarCycle,vec(RadarSize))
                                    holoColor(990+RadarCycle,vec4(255,128,0,32))
                                    holoParent(990+RadarCycle,entity())]#
                                    if(RangingTrace:distance() < RadarDist)
                                    {
                                        SightLockStatus = RangingTrace:entity():isValid() + (RangingTrace:entity():isValid())#what the fuck?
                                        EngagementRange = ((RangingTrace:pos() - Position):length() + RadarSize) / 39.37
                                        RangerCycle = 2
                                        break
                                    }
                                    else
                                    {
                                        RadarCycle++
                                    }
                                }
                            }
                            #laser ranging.  Simple trace aim, for ground attack
                            else
                            {
                                EngagementRange = (Position-AimTrace:position()):length() / 39.37
                                SightLockStatus = AimTrace:entity():isValid()
                            }
                            
                            #sound play for sight, plays a beeping when we're getting a solid return
                            if(changed(SightLockStatus))
                            {
                                soundStop(0)
                                #if(SightLockStatus == 0) {soundStop(0)}
                                #elseif(SightLockStatus == 1) {holoEntity(0):soundPlay(0,0,"acf_extra/airfx/laser_track.wav")}
                                #elseif(SightLockStatus == 2) {holoEntity(0):soundPlay(0,0,"acf_extra/airfx/laser_lock.wav")}
                                soundVolume(0,0.5)
                            }
                        }
                        
                        
                        BombingPullupInput = 0
                        #gun ballistics
                        #aimpos is fixed by holding alt
                        #engagement range is distance to target
                        if(BallisticComputerModeChar == "G")
                        {
                            if(Interval1200Timer)
                            {
                                CannonRangeTable = createGunRangeTable(CannonSelected)
                            }
                            BallisticSolution = createPIPOffRangeTable(CannonRangeTable,EngagementRange,Lead,CannonSelected,CannonSelected:pos(),BaseVel,Lase)
                            if(Interval300Timer)
                            {
                                if(WeaponSelected == 1) {AmmoRatio = CannonSelected:acfTotalAmmoCount() / Cannon_1_Starting_Ammo}
                                elseif(WeaponSelected == 2) {AmmoRatio = CannonSelected:acfTotalAmmoCount() / Cannon_2_Starting_Ammo}
                                elseif(WeaponSelected == 3) {AmmoRatio = CannonSelected:acfTotalAmmoCount() / Cannon_3_Starting_Ammo}
                            }
                            if(!Alt) {Aimpos = Position + (AimForward * EngagementRange * 39.37)}
                        }
                        
                        #bomb ballistics
                        #ccip--pilot controls bomb release
                        #It updates aimpos in realtime, and "fixes" it with alt
                        #note that switching into CCIP by holding B will also act this way of "fixing" aimpos, without a drop signal
                        #engagement range is distance to impact point
                        elseif(BallisticComputerModeChar == "B")
                        {
                            #handles bomb data input, if a bombardier we use that, else if we have an SCRL request we use that
                            if(BombardierAimpos) {AutomatedBombAimpos = BombardierAimpos} else {AutomatedBombAimpos = RemoteDatalinkRequestPoint}
                            local DropSignal = Mouse1 | BombardierDropInput
                            if(!Alt & !Pilot:keyPressed("b") & !RemoteDatalinkWeaponsOverride)  #ccip--shows where your bomb would impact if you dropped it right at this moment
                            {
                                local Bombs = 0
                                foreach(K,V:entity = BombCrates) {Bombs = Bombs + V:acfRounds()}
                                AmmoRatio = Bombs / BOMB_STARTING_AMMO
                                BallisticSolution = bombCCIP(Position + vec(0,0,-118),Forward,Bomb_Range_Table,AvionicsData[3,number],BaseVelLen / 39.37,BaseVel[3] / 39.37)
                                CCIPBombDropAltLast = (Position[3] - BallisticSolution[3]) / 39.37  #stored for interpolation
                                EngagementRange = (BallisticSolution - Position):length() / 39.37
                                DropBombs = DropSignal
                                Aimpos = AimPoint
                            }
                            #ccrp--computer controls bomb release
                            #It updates aimpos when holding drop button, and "fixes" it after that to direct aimtrace piggyback
                            #engagement range is distance until drop
                            else
                            {
                                #aim coord and drop circuit.  note that if you have a bombardier, it'll overwrite; either pilot or bombardier can release bombs
                                if(!RemoteDatalinkWeaponsOverride | !AutomatedBombAimpos)
                                {
                                    BallisticSolution = Aimpos
                                }
                                else
                                {
                                    BallisticSolution = AutomatedBombAimpos
                                }
                                
                                #keep flight computer going towards target if holding alt
                                LockAimpos = Alt
                                
                                if(DropSignal)
                                {
                                    #bombCCIPWithGivenAltitude(Position,Forward,Bomb_Range_Table,AvionicsData[3,number],BaseVelLen / 39.37)
                                    local ImpactPoint = bombCCIPWithGivenAltitude(Position,Forward,Bomb_Range_Table,AvionicsData[3,number],BaseVelLen / 39.37,BaseVel[3] / 39.37)
                                    local BombDifferenceRange = (ImpactPoint - (Aimpos+$Aimpos)):setZ(0):length() / 39.37
                                    BestCCRPDistance = min(BombDifferenceRange,BestCCRPDistance)
                                    if((BombDifferenceRange <= BombCCRPWindow) & (BombDifferenceRange > BestCCRPDistance))
                                    {
                                        DropBombs = 1
                                        if(DropBombs & (BombKg >= 900))
                                        {
                                            #ifdef concmd(string)
                                            concmd("say \"I have become death, the destroyer of pancakes.\"")
                                            #endif
                                            Seat:hintDriver("Dick given!",3)
                                        }
                                        else
                                        {
                                            Seat:hintDriver("Bombs released!",3)
                                        }
                                    }
                                    EngagementRange = BombDifferenceRange
                                    if(!LockAimpos) {Aimpos = AimPoint}
                                    
                                    #pullup
                                    if(State == "MOUSE")
                                    {
                                        BombDiveDiff = entity():toLocal(Aimpos)[1] - entity():toLocal(ImpactPoint)[1]
                                        BombingPullupInput = (BombDiveDiff + $BombDiveDiff/ AvionicsData[3,number]) * BOMBING_PULLUP_AMOUNT
                                    }
                                }
                                else
                                {
                                    BestCCRPDistance = 9999
                                    DropBombs = 0
                                }
                            }
                        }
                        
                        #missile ballistics
                        #aimpos is fixed if not holding fire key or alt
                        #engagement range is distance to target
                        #split and weirdly written because we can't pass missile1/2 range table by pointer.  Least i don't think so.
                        elseif(BallisticComputerModeChar == "M")
                        {
                            local Missiles = 0
                            if(WeaponSelected == 2)
                            {
                                BallisticSolution = createPIPOffRangeTable(Missile_2_Range_Table,EngagementRange,Lead,entity(),Position,BaseVel,Lase*2)
                                if(Interval300Timer)
                                {
                                    foreach(K,V:entity = Missile_2_Crates) {Missiles = Missiles + V:acfRounds()}
                                    AmmoRatio = Missiles / Missile_2_Starting_Ammo
                                }
                            }
                            elseif(WeaponSelected == 1)
                            {
                                BallisticSolution = createPIPOffRangeTable(Missile_1_Range_Table,EngagementRange,Lead,entity(),Position,BaseVel,Lase*2)
                                if(Interval300Timer)
                                {
                                    foreach(K,V:entity = Missile_1_Crates) {Missiles = Missiles + V:acfRounds()}
                                    AmmoRatio = Missiles / Missile_1_Starting_Ammo
                                }
                            }
                            if(FireMissile1 | FireMissile2 | Alt)
                            {
                                Aimpos = AimPoint
                            }
                        }
                        
                        #not armed, in safe mode
                        #
                        elseif(BallisticComputerModeChar == "N")
                        {
                            if(BombardierAimpos) {BallisticSolution = BombardierAimpos} elseif(RemoteDatalinkRequestPoint) {BallisticSolution = RemoteDatalinkRequestPoint} else {BallisticSolution = (Position + (Forward * 39370))}
                            EngagementRange = (AimPoint-Position):length() / 39.37
                            Aimpos = AimPoint
                        }
                        
                        #pass-through for aiming with remotely uploaded data
                        if(RemoteDatalinkWeaponsOverride) {Aimpos = RemoteDatalinkRequestPoint}
                    }
                    #range is just used in nav mode
                    else
                    {
                        EngagementRange = (AimPoint-Position):length() / 39.37
                    }
                    #clamping engagement range
                    EngagementRange = clamp(EngagementRange,40,800)
                    
                    GForceSpeed = (Velocity:length() + (abs(LocalVel[3]) * 0.5) + (vec($Angle):length())) * 5
                    #misc holo
                    if(!CamDisabled)
                    {
                        #heads-up display
                        if(Piloted & Is_Armed) {HudReturn = updateHoloHud(182,EngagementRange,BallisticSolution,AimLoc,ThirdPerson | CamThroughGunsight,HudReturn)}
                        #holo flight controls are updated
                        if(!ThirdPerson & Piloted) {updateHoloFlightControls(191,Interval300Timer,Seat,Mouse1 & !R,Flight_Model["cyclic or collective",number],Flight_Model["forward engine thrust",number],OptionalCollectivePosition,OptionalThrottlePosition,WS,AD,LR,UD,FB)}
                        #gforce code ferv added
                        #1 G = 386.0886 inch per second per second
                        #60 in/s^2 over 150ms = 400 in/s^2 over 1 second = 1.04 Gs
                        GForceAlpha = (GForceAlpha * 0.9) + (max(($GForceSpeed)-60,0) * 0.075)
                        holoAlpha(44,min(GForceAlpha,255)) #gforce holo
                    }
                    
                    if(Interval300Timer)
                    {
                        #Wartime emergency power or afterburner, hook it up to an external system
                        WEP = (FB * Input_FB) == 1
                        #gear brakes
                        Gear_Brakes = ((FB <= 0) & (Input_FB == -1)) | ((UD == 0) & (Input_UD == -1) & Flight_Model["collective",number]) & (Gear_Down)
                        #thrust reverser
                        ThrustReverser = (FB < 0)
                        #updates avionics data and instruments
                        AvionicsData = updateAvionicsTelemetry(AvionicsData)
                        if(!ThirdPerson & !CamDisabled) {updateHoloInstruments(160,AvionicsData[1,number],AvionicsData[2,angle],AvionicsData[3,number],AvionicsData[4,number],AmmoRatio * 100)}
                        
                        #Here is where I stuff shit that is to run only every few executions--this is a lag saving measure
                        #A holo timer, used to slow and accelerate the rotors and props
                        StartSequence = clamp(StartSequence+StartupSpeed,StartSequence,1)
                        
                        #Sound.  Engine pitch and flaps
                        local EpitchIn = 80                            
                        if(Flight_Model["collective",number])
                        {
                            EpitchIn = EpitchIn + (UD * 40)
                        }
                        if(Flight_Model["forward engine thrust",number])
                        {
                            EpitchIn = EpitchIn + (FB * 40)
                            soundVolume(4,clamp(UD * (Velocity:length() / Flight_Model["stall",number]) * StartSequence,0,1))
                        }
                        EpitchIn = min(EpitchIn * StartSequence,120) #jumpjets and shit have mixed thrust requirements
                        EnginePitch = clamp(EpitchIn,EnginePitch-10,EnginePitch+10)
                        if(changed(EnginePitch))
                        {
                            soundPitch(2,abs(EnginePitch+100)/2)
                            soundPitch(3,EnginePitch)
                        }
                        
                        #damage and crash code
                        DamageSystemSpeed = ($LocalVel):length()
                        #detect if UAV
                        if(Interval1200Timer)
                        {
                            local DistFromPod = (Position - Seat:pos()):length()
                            if(DistFromPod > (393.7)) #10m
                            {
                                DamageSystemStart = curtime() + 1.5
                            }
                        }
                        
                        #damage
                        if(curtime() > DamageSystemStart)
                        {
                            local DeltaDamageSystemSpeed = abs($DamageSystemSpeed)
                            local PlayStressSound = (DeltaDamageSystemSpeed > 50) | (WEP)
                            local LandingGearDamage = 0
                            if(PlayStressSound)
                            {
                                soundPlay(400 + randint(100),1,"ambient/materials/metal_stress" + randint(5) + ".wav")
                                #hardcoded to make harder to tamper with.
                                LandingGearDamage = (DeltaDamageSystemSpeed > 150) & Gear_Down
                                DamageStructural = max(DeltaDamageSystemSpeed > 300,DamageStructural)
                            }
                            if(LandingGearDamage & LandingGear:count())
                            {
                                Base:soundPlay(100,0,"ambient/materials/cartrap_explode_impact2.wav")
                                local Boomed = 0
                                #ifdef entity:removeAllConstraints()
                                foreach(K,V:entity = LandingGear) {V:removeAllConstraints()}
                                Boomed++
                                #endif
                                #ifdef entity:constraintBreak()
                                foreach(K,V:entity = LandingGear) {V:constraintBreak()}
                                Boomed++
                                #endif
                                LandingGear = array()
                                if(Boomed) {Seat:printDriver("Your landing gear has been destroyed!")}
                            }
                            if(Interval1200Timer | DamageStructural)
                            {
                                #
                                DamageBaseCount = 0
                                for(N=1,Airframe_Bases:count()) {DamageBaseCount += Airframe_Bases[N,entity]:isValid()}
                                #If you decelerate too hard, it will kill the pilot, remove random props, recolor for damage, and then go kill itself.
                                #The maximum allowed deceleration is around 20mph or so.
                                
                                if(DamageStructural)
                                {
                                    Seat:soundPlay(100,0,"ambient/materials/cartrap_explode_impact2.wav")
                                    Base:soundPlay(299,0,"ambient/materials/cartrap_explode_impact1.wav")
                                    if((Seat:pos() - Position):length() < 393.7) {Seat:killPod()} #10m away we're safe
                                    foreach(K,V:entity = Airframe_Bases)
                                    {
                                        #ifdef entity:constraintBreak()
                                        V:constraintBreak()
                                        #endif
                                        #ifdef entity:removeAllConstraints()
                                        V:removeAllConstraints()
                                        #endif
                                    }
                                    foreach(K,V:entity = Self)
                                    {
                                        N = random(1)
                                        if(N > 0.9)
                                        {
                                            if(V:parent():isValid())
                                            {
                                                #ifdef entity:deparent()
                                                V:deparent()
                                                #V:applyForce(Velocity * V:mass() * 1)
                                                #endif
                                            }
                                            elseif(V:mass() > 25)
                                            {
                                                #ifdef entity:constraintBreak()
                                                V:constraintBreak()
                                                #endif
                                                #ifdef entity:removeAllConstraints()
                                                V:removeAllConstraints()
                                                #endif
                                            }
                                            V:setMaterial("Models/props_trainstation/Trainstation_Ornament001")
                                        }
                                        elseif(N <= 0.1) {V:setMaterial("Models/props_trainstation/Trainstation_Ornament001")}
                                        elseif(N <= 0.2) {V:setColor(V:getColor()*vec(0.5,0.5,0.5))}
                                        elseif(N <= 0.3) {V:setMaterial("models/props_c17/metalladder002")}
                                        elseif(N <= 0.4) {V:setColor(V:getColor() * vec(0.7,0.6,0.6))}
                                        elseif((V:type() != "gmod_wire_gate") & (V != Base))
                                        {#ifdef entity:propDelete()
                                            V:propDelete()
                                        #endif
                                        }
                                    }
                                    selfDestruct()
                                }
                                
                                #Alternatively, if you lose a "base" prop, a core and vital component, you will lose all control, but the pilot will survive.
                                else
                                {
                                    
                                    if(((DamageBaseCount < Airframe_Bases_Number) & !DieTimer) | (WepCool > 5))
                                    {
                                        Base:soundPlay(298,0,"ambient/materials/cartrap_explode_impact1.wav")
                                        Airframe_Bases:entity(2):soundPlay(299,0,"ambient/materials/cartrap_explode_impact1.wav")
                                        Airframe_Bases:entity(3):soundPlay(300,0,"ambient/materials/cartrap_explode_impact1.wav")
                                        DieTimer = curtime() + 5 #you're gonna fucking die, bro.
                                        soundPlay(200,0,"acf_extra/airfx/heli_damage_rotor_" + randint(2) + ".wav")
                                        Seat:soundPlay(201,0,"acf_extra/airfx/heli_damage_tail.wav")
                                        #ifdef effect:setMagnitude(number)
                                        for(N=1,Airframe_Bases_Number)
                                        {
                                            BurnEffects[N,effect] = effect()
                                            BurnEffects[N,effect]:setEntity(Airframe_Bases[N,entity])
                                            BurnEffects[N,effect]:setFlags(4)
                                            BurnEffects[N,effect]:play("Explosion")
                                        }
                                        #endif
                                        for(N=1,Airframe_Bases_Number)
                                        {
                                            Airframe_Bases[N,entity]:soundPlay(200+N,0,"ambient/materials/metal_rattle.wav")
                                        }
                                        soundStop(2)
                                        soundStop(3)
                                    }
                                }
                            }
                        }
                        #taxi multiplier, makes turning way the fuck faster under 3m/s on ground with very low throttle and holding A&D in mouse mode
                        if((A&D) | R) {TaxiMultiplier = clamp(1-(AvionicsData[3,number] / 2.5),0,max(0.25 - abs(FB),0)) * (BaseVelLen < 118.11) * 19} else {TaxiMultiplier = 0}
                        
                        #hardcode, because if you remove this I will murder your fucking face.
                        if(WEP & ->WEP) {WepCool += 0.3} elseif(WepCool) {WepCool = max(WepCool - 0.1,0)}
                        FireWarning = WepCool > 3
                        if(changed(FireWarning))
                        {
                            if(FireWarning) {soundPlay("fire",0,"acf_extra/airfx/fire_alarm.wav")} else {soundStop("fire")}
                        }
                    }
                    
                    #landing gear deparent
                    if(LandingGearReinflationCycle)
                    {
                        if(Interval300Timer)
                        {
                            #reweights ALL gear slowly
                            #ifdef entity:setMass(number)
                            local Ratio = 1 - ((LandingGearReinflationCycle-1) / 5)
                            for(N=1,LandingGear:count())
                            {
                                local WeightToUse = LandingGearWeights[N,number] * Ratio
                                LandingGear[N,entity]:setMass(1.25 + ((WeightToUse-1.25) * Gear_Down))
                            }
                            LandingGearReinflationCycle--
                            #else
                            LandingGearReinflationCycle = 0
                            #endif
                            
                        }
                    }
                }#end half-rate toggle
                
            #burning and about to die                        
            if(DieTimer)
            {
                if(curtime() < DieTimer)
                {
                    #ifdef effect:setMagnitude(number)
                    for(N=1,Airframe_Bases_Number)
                    {
                        BurnEffects[N,effect]:setOrigin(Airframe_Bases[N,entity]:pos())
                        #BurnEffects[N,effect]:setFlags(4) //shouldn't need this
                        BurnEffects[N,effect]:play("Explosion")
                    }
                    #endif
                }
                else
                {
                    DamageStructural++
                }
            }
            
            
            #Building angular rotation & directional force models
            #This is wing based lift and gorund effect
            if(Interval300Timer)
            {
                if(Flight_Model["wings",number])#if it has wings, it must make lift from them; rotors help but less
                {
                    local FlapAdjustedStall = Flight_Model["stall",number] * (1-(UD * FLAP_EFFECTIVENESS))
                    #This is a new way of doing it by a rough sinusoidal curve purely for "feel" and a raw value
                    local RawStall = abs(Velocity[1]) / FlapAdjustedStall
                    LiftRatio = clamp((RawStall * 0.5) + (sin(RawStall*90)/180),0,1) #creates a ratio of lift, as you go faster it increases until you hit cruising speed
                    ControlRatio = clamp(LiftRatio,MIN_CONTROL_VALUE,AltitudeEffectValue) #Creates a ratio off the lift ratio for control surface mobility #adjusted from ,1.25)/1.25 for simplicity, may slightlya djust curve
                    FlapDampening = 1 + ((FLAP_EFFECTIVENESS*UD)*3*AltitudeEffectValue)
                    PlaneLiftAdjustment = LiftRatio * Flight_Model["lift fin effect",number]
                    #reduces dampening at hard stalls
                    local StallCutoffRatio = Flight_Model["stall",number] / 1   #TODO: PRECACHE
                    StallDampening = (clamp(Velocity:length(),0,StallCutoffRatio) / (StallCutoffRatio * 2)) + 0.5 #should go 0.5-1
                }
                elseif(Flight_Model["cyclic",number] | Flight_Model["collective",number])
                {
                    LiftRatio = (Flight_Model["lift fin effect",number] * clamp(BaseVelLen / 1000,0,1))
                    ControlRatio = AltitudeEffectValue
                }
                else 
                {
                    ControlRatio = AltitudeEffectValue
                }
                
                #altitude effect, reduces lift and maneuverability at very high altitudes
                AltitudeEffectValue = (AltitudeEffectValue * 0.75) + (clamp(1 - (AvionicsData[3,number] / 1000),0,1) * 0.25)
                #ground effect, provides greatly increased lift and dust at very low altitude
                local GroundEffectIntensity = clamp((7-AvionicsData[3,number]) / 7,0,1)
                GroundEffectValue = GroundEffectIntensity * (Flight_Model["ground effect multiplier",number])   #ground effect, extra lift up to 7m of ground
                #Dust kickup and sound code
                if(Flight_Model["cyclic or collective",number])
                {
                    DustKickingUp = GroundEffectValue != 0
                    if(DustKickingUp)
                    {
                        if($DustKickingUp)
                        {
                            soundPlay(200,0,"acf_extra/vehiclefx/misc/windrush_in.wav")
                            #ifdef effect:setMagnitude(number)
                            DustEffect = effect()
                            DustEffect:setEntity(Airframe_Bases[1,entity])
                            DustEffect:setMagnitude(10)
                            DustEffect:setRadius(1000)
                            WaterEffect = effect()
                            WaterEffect:setEntity(Airframe_Bases[1,entity])
                            WaterEffect:setMagnitude(10)
                            WaterEffect:setRadius(1000)
                            #endif
                        }
                        #ifdef effect:setMagnitude(number)
                        local EffectPos = Position - vec(0,0,AvionicsData[3,number] * 39)
                        local EffectScale = GroundEffectIntensity * 150
                        DustEffect:setOrigin(EffectPos)
                        DustEffect:setScale(EffectScale)   #this should be like 500-0 based off altitude for mpfc using ThumperDust
                        DustEffect:play("ThumperDust")
                        WaterEffect:setOrigin(EffectPos)
                        WaterEffect:setScale(EffectScale/2)   #this should be like 500-0 based off altitude for mpfc using ThumperDust
                        WaterEffect:play("waterripple")
                        #endif
                        soundVolume(200,GroundEffectIntensity / 2)
                    }
                    else
                    {
                        if($DustKickingUp) {soundStop(200)}
                    }
                }
                
                local AirDensity = AltitudeEffectValue#(0.5 + AltitudeEffectValue) * 0.667
                FlightCPUAirDensityVector = vec(AirDensity,AirDensity,1)
                
                
                #backcheck that halts CPU on random op spikes
                #meh fuck it
                #CPU = cpuUsage() * 1000000
            }
            
            #if we're dead, we can't apply forces.  This is where all the force code is done
            if(!DieTimer)
            {
                #collective and forward force updates
                if(changed(UD) | changed(FB))
                {
                    if(Flight_Model["collective",number])#if it has rotors, make it lift from those
                    {
                        CollectiveForce = UD * (1-(FB*Flight_Model["collective throttle blending",number]))
                    }
                    if(Flight_Model["forward engine thrust",number])#if it has thrust, it should use that
                    {
                        ThrustForce = (FB * (1-(UD*Flight_Model["collective throttle blending",number]))) * Flight_Model["forward engine thrust",number]
                    }
                }
                
                #cyclic from helicopters
                if(Flight_Model["cyclic",number])#if it has cyclic, that could be useful to us as well
                {
                    local AngForCyclic = clamp(Angle,CYCLIC_LOW_LIMIT,CYCLIC_HIGH_LIMIT)
                    Cyclic = vec(AngForCyclic[1],-AngForCyclic[3],0)/CYCLIC_LIMIT
                    if(Flight_Model["cyclic tail mixing",number]) {CyclicTailAddition = (Cyclic[1] * -Cyclic[3]) * Flight_Model["cyclic tail mixing",number]}#Drift from cyclic
                }
                
                #Computing flight characteristics into raw values; very confusing, so try not to fuck with it
                local FlightCPUDampeningVectorForce = Velocity*Flight_Model["damping",vector] * FlapDampening * FlightCPUAirDensityVector * (vec(1,1,1+PlaneLiftAdjustment)) * StallDampening
                local FlightCPUAppliedVectorForce = (vec(ThrustForce,0,clamp(CollectiveForce+LiftRatio,0,1 + LiftRatio) * (1 + GroundEffectValue)) + Cyclic) * Flight_Model["thrust",vector]
                local FlightCPUVector = entity():toWorld((FlightCPUAppliedVectorForce + (FlightCPUDampeningVectorForce) ) * AltitudeEffectValue * StartSequence) - Position
                local QuatAng = (ang(-(WS*Flight_Model["maneuverability",angle][1])*ControlRatio,((CyclicTailAddition-LR)*(Flight_Model["maneuverability",angle][2] * 1+TaxiMultiplier))*ControlRatio,(AD*Flight_Model["maneuverability",angle][3])*ControlRatio))
                #close to ground this shit cocks up, so we gradually ease into it
                #it's a self-correction of the target angle, it counter-tilts slightly to help "drag" the aircraft back on target
                #Note: DO NOT add a derivative, because the phase shift is already bad enough
                DiffAng = clamp((-entity():toLocal(FlightCPUAngle)) * clamp(AvionicsData[3,number] / 10,0,0.1),ang(FLIGHT_CPU_INTEGRAL_LOWER_LIMIT),ang(FLIGHT_CPU_INTEGRAL_UPPER_LIMIT))
                DiffAng = clamp(DiffAng,DiffAng-ang(1),DiffAng+ang(1))
                DiffAngI = clamp(DiffAngI + (DiffAng * FLIGHT_CPU_INTEGRAL_GAIN),ang(FLIGHT_CPU_INTEGRAL_LOWER_LIMIT),ang(FLIGHT_CPU_INTEGRAL_UPPER_LIMIT))
                local DiffAngD = $DiffAng * FLIGHT_CPU_DERIVATIVE
                Orientation = Orientation * quat(QuatAng)
                FlightCPUAngle = Orientation:toAngle()
                local DiffAngPID = DiffAng + DiffAngI + DiffAngD
                
                #Quaternion localization
                local TarQ = quat(FlightCPUAngle - (DiffAngPID * 2)) #Calculate quaternion for target orientation #TarQ = quat(Cam["CamAng",angle] + ang(0,0,(Pilot:keyPressed("A") - (Pilot:keyPressed("D"))) * 25))
                #DEBUGlocal TarQ = quat(Cam["CamAng",angle] + ang(0,0,(Pilot:keyPressed("A") - (Pilot:keyPressed("D"))) * -15))
                local CurQ = quat(Angle + DiffAngPID) #Calculate current orientation quaternion # - ((DiffAng + DiffAngI + $DiffAng))
                #TarQ/CurQ is a quaternion representing the rotation that will rotate the object from current orientation to the target one.
                local Q = (TarQ/CurQ)
                #PID of the rotation vector--does gymbal lock, but the amount is very limited so phase-shift is unnoticeable.  We offset derivative phase shift to slightly.
                RotVecP = rotationVector(Q)
                RotVecI = clamp(RotVecI + (RotVecP * FLIGHT_CPU_INTEGRAL_GAIN * 1.2),FLIGHT_CPU_INTEGRAL_LOWER_LIMIT,FLIGHT_CPU_INTEGRAL_UPPER_LIMIT)
                RotVecD = $RotVecP * FLIGHT_CPU_DERIVATIVE
                local RotVec = RotVecP + RotVecI + RotVecD
                local COG_Rot = entity():toWorld(-COG_Offset)
                #Application of actual force
                for(X=1,Airframe_Bases_Number)
                {
                    if(!Airframe_Bases_Airframe_Bases_Unconstrained[X,number])
                    {
                        if(!Airframe_Bases_Unwelded[X,number])
                        {
                            #local DiffTorque = (Airframe_Bases[X,entity]:toLocal(RotVec + COG_Rot)) * Angular_Force
                            #old, seems more prone to issue though
                            local DiffTorque = (Airframe_Bases[X,entity]:toLocal(RotVec + Airframe_Bases[X,entity]:pos())) * Angular_Force
                            local DampTorque = Airframe_Bases[X,entity]:angVelVector() * Angular_Dampening
                            local ForceMultiplier = Airframe_Bases_Inertias[X,vector]
                            Airframe_Bases[X,entity]:applyTorque((DiffTorque - DampTorque) * ForceMultiplier)
                        }
                        Airframe_Bases[X,entity]:applyForce(FlightCPUVector * Airframe_Bases_Masses[X,number] * 1.25)
                        #Airframe_Bases[X,entity]:applyOffsetForce(FlightCPUVector * Airframe_Bases_Masses[X,number] * 1.3,COG)
                    }
                }
            }
        }
    }
}

#[
###################################################################################################
#Here's a copy of varlib, copy-paste into a new e2
###################################################################################################

@name MPFC v7 VarLib
@outputs [VarLib]:array
@model models/bull/gates/microcontroller1_mini.mdl
#READ THIS SHIT BELOW BEFORE YOU WONDER WHY THINGS ARE BROKEN PLEAAAAAAASE!!! --red
#FLIGHT MODELS:
#0------------Glider
#1------------Biplane
#2------------Parasol plane
#3------------Monoplane
#4------------Jumpjet
#5------------Airship
#6------------Helicopter
#7------------Gyrodyne
#8------------Autogyro
#9------------Ekranoplan

#Keys for weapons, in the ballistic computer
#BOMBS:
#50      50kg bomb
#100     100kg bomb
#250     250kg bomb
#500     500kg bomb
#1000    1000kg bomb
#62      AGM-62 guided bomb
#227     227kg guided bomb
#454     454kg guided bomb
#909     909kg guided bomb
#70      70mm ffar, with no propellant, firing forward as a cluster munition
#-1      parachute pod

#MISSILES:
#S24    S-24 missile
#HVAR   HVAR missile
#RS82		RS82 missile
#ZUNI   Zuni missile
#70MMFFAR	70mm FFAR pod
#40MMFFAR	40mm FFAR pod
#ATAKA		Ataka missile
#AT3		AT-3 missile
#AGM114		AGM-114 hellfire missile
#AT2		AT-2 missile
#AGM45		AGM-45 shrike missile
#AGM122		AGM-122 sidearm missile
#BGM71		BGM-71 TOW missile

#Note that guided weapons have range tables too!  This helps you drop them at the best angle, so that they reach farther and are more accurate
#The parachute pod is a pod which can be used to, you guessed it, drop paratroopers.
#The range table lets you drop them like bombs, so they don't go everywhere.  You can dowload it from here:
#https://www.dropbox.com/s/bwsgbaxknsp63j6/Parachute%20Pod%20For%20Paratroopers.txt?dl=0

#Varlib for flight chip
local Maneuverability = 1.4 #modifier for maneuverability
local Thrust = 1				      #forward or lateral thrust, it's all meshed the same
local Lift = 1.1			         #Lift force ratio, may adjust to work with some autohovering governor
local Cruisespeed = 500			#max lift at this, used to create stall ratios
local Typeofvehicle = 3			#selects flight model
#Sounds
local CockpitSound = "acf_extra/airfx/cockpit_plane.wav"			#Sound that plays in the cockpit
local EngineSound = "acf_extra/airfx/usag.wav"				#Sound that plays from engine
local PropSound = "acf_extra/airfx/pipercub.wav"				#Sound that plays from rotors or thrusting, static and unchanging.
local SwitchSound = "buttons/lever7.wav"				#Sound that plays when you switch master circuit
local GetInSound = "buttons/latchunlocked2.wav"				#Sound that plays when someone gets in the seat
local StartSound = "acf_extra/airfx/satellite_target.wav"      #Sound that plays as the engine turns over
#Optional holo--ignore unless youo're using these parts
local Scale = vec(1)          #Scale of your main rotors
local RotorBlades = 5             #Blades on main rotors
local TailScale = vec(1)      #Scale of your tail rotor
local TailRotorBlades = 2         #Blades on tail rotor
local PropellorScale = 0.7 #Size of your propellors
local PropellorBlades = 3 #Blades on your propellors
local TailAngleSwap = 0 #0 or 1, swaps the side the tail rotor is on
#Cam offset from base
local CamOffset = vec(0,0,50)
#stick limits
local StickLimits = 15
#bomb caliber--for ballistics for full he, full size bombs.  This is where you enter the kg in the bomb list above
local BombKg = 100
#dark backing on your flight instrument panel?  1/0
local DarkBacking = 1
#size of instrument panel, number--best between 0.5-1
local InstrumentPanelScale = 0.8
#Missile ballistic data; type of missile.  This is where you enter the keys in the missile list above
local MissileType1 = ""
local MissileType2 = ""
#landing gear model; we use propnotsolid/setalpha/setmass/parenting to automatically handle landing gear
#if you don't want to use the automatic gear thing, just enter nothing.
local GearModel = "models/sprops/trans/wheel_c/t_wheel30.mdl"

#DO NOT EDIT THIS UNLESS YOU KNOW WHAT YOU'RE DOING!
#Custom override of force values.  It WILL NOT make you turn/fly faster, but it will force the PID to "jerk" harder for very offset shapes.
#the default in mpfc is 10/3 or so, but some airframes can take up to as much as 16/4.
#at 0,0 it'll just default.
local CustomForceValues = vec2(0,0)

#Building Variable library which mpfc consumes
VarLib = array(Maneuverability,Thrust,Lift,Cruisespeed,Typeofvehicle,0,0,0,StickLimits,vec(0,0,0),CockpitSound,EngineSound,PropSound,SwitchSound,GetInSound,StartSound,0,Scale,RotorBlades,TailScale,TailRotorBlades,PropellorScale,PropellorBlades,TailAngleSwap,CamOffset,StickLimits,BombKg,DarkBacking,InstrumentPanelScale,MissileType1,MissileType2,GearModel,CustomForceValues)
